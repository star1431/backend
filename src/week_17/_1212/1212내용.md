# [ 17주차 - 1212 ]

```bash
    금일 커리큘럼
        ├ 09:00 ~ 12:00 FrontEnd (React - 비동기 통신 (Fetch API))
        └ 13:00 ~ 18:00 FrontEnd (React - Router와 Link, 복습 및 실습)
```


## 1. React - 비동기 통신 (Fetch API)

### 1.1 fetch API 란?

- 브라우저에서 제공하는 네이티브 API로, 서버와의 HTTP 통신을 위한 인터페이스
- Promise 기반으로 동작하여 비동기 처리가 가능
- XMLHttpRequest의 대안으로 더 간단하고 현대적인 방식
- React에서 서버로부터 데이터를 가져오거나 전송할 때 주로 사용

```javascript
// 기본 fetch 사용법
fetch('https://api.example.com/data')
  .then(response => response.json())
  .then(data => console.log(data))
  .catch(error => console.error('Error:', error));
```

- `fetch()`는 Promise를 반환하므로 `.then()`과 `.catch()`로 처리 가능
- 첫 번째 `.then()`에서는 Response 객체를 받아 `.json()`, `.text()` 등으로 변환
- 두 번째 `.then()`에서는 변환된 데이터를 받아 처리

---

### 1.2 데이터 요청 (GET, POST, DELETE)

#### GET 요청 (데이터 조회)

```javascript
import { useState, useEffect } from 'react';

const DataFetch = () => {
  const [data, setData] = useState(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);

  useEffect(() => {
    // GET 요청
    fetch('https://jsonplaceholder.typicode.com/posts/1')
      .then(response => {
        if (!response.ok) {
          throw new Error('Network response was not ok');
        }
        return response.json();
      })
      .then(data => {
        setData(data);
        setLoading(false);
      })
      .catch(error => {
        setError(error.message);
        setLoading(false);
      });
  }, []);

  if (loading) return <div>Loading...</div>;
  if (error) return <div>Error: {error}</div>;

  return (
    <div>
      <h3>{data?.title}</h3>
      <p>{data?.body}</p>
    </div>
  );
};

export default DataFetch;
```

#### POST 요청 (데이터 생성)

```javascript
import { useState } from 'react';

const PostData = () => {
  const [title, setTitle] = useState('');
  const [body, setBody] = useState('');

  const handleSubmit = () => {
    // POST 요청
    fetch('https://jsonplaceholder.typicode.com/posts', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({
        title: title,
        body: body,
        userId: 1,
      }),
    })
      .then(response => response.json())
      .then(data => {
        console.log('Success:', data);
        alert('등록 완료!');
        setTitle('');
        setBody('');
      })
      .catch(error => {
        console.error('Error:', error);
        alert('등록 실패!');
      });
  };

  return (
    <div>
      <input
        type="text"
        placeholder="제목"
        value={title}
        onChange={(e) => setTitle(e.target.value)}
      />
      <textarea
        placeholder="내용"
        value={body}
        onChange={(e) => setBody(e.target.value)}
      />
      <button onClick={handleSubmit}>등록</button>
    </div>
  );
};

export default PostData;
```

#### DELETE 요청 (데이터 삭제)

```javascript
import { useState } from 'react';

const DeleteData = () => {
  const [postId, setPostId] = useState('');

  const handleDelete = () => {
    if (!postId) {
      alert('ID를 입력하세요');
      return;
    }

    // DELETE 요청
    fetch(`https://jsonplaceholder.typicode.com/posts/${postId}`, {
      method: 'DELETE',
    })
      .then(response => {
        if (response.ok) {
          alert('삭제 완료!');
          setPostId('');
        } else {
          throw new Error('삭제 실패');
        }
      })
      .catch(error => {
        console.error('Error:', error);
        alert('삭제 실패!');
      });
  };

  return (
    <div>
      <input
        type="number"
        placeholder="삭제할 ID"
        value={postId}
        onChange={(e) => setPostId(e.target.value)}
      />
      <button onClick={handleDelete}>삭제</button>
    </div>
  );
};

export default DeleteData;
```

- **GET**: 데이터 조회 시 사용, 기본 메서드이므로 `method` 옵션 생략 가능
- **POST**: 데이터 생성 시 사용, `body`에 JSON 형식으로 데이터 전송
- **DELETE**: 데이터 삭제 시 사용, URL에 삭제할 리소스의 ID 포함

---

### 1.3 async / await 문법

- `async/await`는 Promise를 더 간결하고 읽기 쉽게 처리하는 문법
- `async` 함수는 항상 Promise를 반환
- `await` 키워드는 Promise가 완료될 때까지 함수 실행을 일시 중지
- `try...catch`로 에러 처리 가능

```javascript
import { useState, useEffect } from 'react';

const AsyncFetch = () => {
  const [data, setData] = useState(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);

  useEffect(() => {
    // async 함수 정의
    const fetchData = async () => {
      try {
        // await로 Promise 완료 대기
        const response = await fetch('https://jsonplaceholder.typicode.com/posts/1');
        
        if (!response.ok) {
          throw new Error('Network response was not ok');
        }
        
        const jsonData = await response.json();
        setData(jsonData);
        setLoading(false);
      } catch (err) {
        setError(err.message);
        setLoading(false);
      }
    };

    fetchData();
  }, []);

  if (loading) return <div>Loading...</div>;
  if (error) return <div>Error: {error}</div>;

  return (
    <div>
      <h3>{data?.title}</h3>
      <p>{data?.body}</p>
    </div>
  );
};

export default AsyncFetch;
```

#### async/await와 Promise 비교

```javascript
// Promise 방식 (.then())
fetch('https://api.example.com/data')
  .then(response => response.json())
  .then(data => console.log(data))
  .catch(error => console.error(error));

// async/await 방식 (더 읽기 쉬움)
const fetchData = async () => {
  try {
    const response = await fetch('https://api.example.com/data');
    const data = await response.json();
    console.log(data);
  } catch (error) {
    console.error(error);
  }
};
```

- `async/await`는 코드가 더 직관적이고 읽기 쉬움
- 에러 처리를 `try...catch`로 통일하여 관리하기 편함
- 여러 비동기 작업을 순차적으로 처리할 때 유용



### 1.4 api.js로 별도 관리 및 사용 방식

#### api.js

- localhost:8081/api/ 기준

```javascript
const API_BASE_URL = 'http://localhost:8081/api';
const JSON_HEADERS = {
    'Content-Type': 'application/json',
};
/**
 * 모든 Todo 조회
 * @returns {Promise<Array>} Todo 배열
 */
const getAllTodos = async () => {
    try {
        const response = await fetch(`${API_BASE_URL}/todos`);
        if (!response.ok) {
            throw new Error('[todoAPI] Todo 목록을 불러오는데 실패했습니다.');
        }
        // 응답 데이터는 1번만 사용 가능 (스트림 방식임)
        // 그래서 변수에 담아둬서 사용 로그,리턴 등 여러번 활용
        const data = await response.json();
        console.log('[todoAPI] getAllTodos data:', data);
        return data;
    } catch (error) {
        console.error('[todoAPI] getAllTodos error:', error);
        throw error;
    }
};

const createTodo = async (text) => {
    try {
        const response = await fetch(`${API_BASE_URL}/todos`, {
            method: 'POST',
            headers: JSON_HEADERS,
            // stringify : 객체 -> JSON 문자열 변환
            body: JSON.stringify({ text , completed: false }),
        });
        if (!response.ok) {
            throw new Error('[todoAPI] Todo 생성에 실패했습니다.');
        }
        const data = await response.json();
        console.log('[todoAPI] createTodo data:', data);
        return data;
    } catch (error) {
        console.error('[todoAPI] createTodo error:', error);
        throw error;
    }
}

const deleteTodo = async (id) => {
    try {
        const response = await fetch(`${API_BASE_URL}/todos/${id}`, {
            method: 'DELETE',
        });
        if (!response.ok) {
            throw new Error('[todoAPI] Todo 삭제에 실패했습니다.');
        }
        console.log(`[todoAPI] deleteTodo id:${id}`);
    } catch (error) {
        console.error('[todoAPI] deleteTodo error:', error);
        throw error;
    }
}

const toggleCompleteTodo = async (id, completed) => {
    try {
        const response = await fetch(`${API_BASE_URL}/todos/${id}`, {
            method: 'PUT',
            headers: JSON_HEADERS,
            body: JSON.stringify({ completed }),
        });
        if (!response.ok) {
            throw new Error('[todoAPI] Todo 완료 상태 변경에 실패했습니다.');
        }
        const data = await response.json();
        console.log('[todoAPI] toggleCompleteTodo data:', data);
        return data;
    } catch (error) {
        console.error('[todoAPI] toggleCompleteTodo error:', error);
        throw error;
    }
}

export {
    getAllTodos,
    createTodo,
    deleteTodo,
    toggleCompleteTodo
}
```

- todo 관련 컴포넌트

```javascript
import { useState, useEffect } from "react";

import { getAllTodos, createTodo, deleteTodo, toggleCompleteTodo } from "/src/api/todoApi.js";

const TodoItem = ({ todo , onDel, onToggle  }) => {
    const handleDel = () => {
        onDel(todo.id); // 부모에게 id 전달
    }

    // api 추가 이후 완료 토글 핸들러
    const handleToggle = () => {
        onToggle(todo.id, !todo.completed);
    };

    return (
        <div className="todo-item">
            <div className="todo-slot">
                {/* <input 
                    id={`todo-${todo.id}`} 
                    type="checkbox" 
                    defaultChecked={todo.completed}
                /> */}
                {/* api 사용하기에 checked로 변경 및 onChange 핸들러 추가 */}
                <input 
                    id={`todo-${todo.id}`} 
                    type="checkbox" 
                    checked={todo.completed}
                    onChange={handleToggle}
                />
                <label htmlFor={`todo-${todo.id}`}>{todo.text}</label>
            </div>
            <div className="todo-slot right">
                <button className="btn-exam type-icon del" onClick={handleDel}>
                    <span className="hidden">삭제</span>
                </button>
            </div>
        </div>
    );
}

const TodoInput = ({ onAdd }) => {
    const [input, setInput] = useState('');

    const handleAdd = () => {
        onAdd(input); // 부모에게 입력값 전달
        setInput('');
    }

    return (
        <div className="input-add-box">
            <input
                className="todo-input"
                type="text"
                value={input}
                onChange={(e) => setInput(e.target.value)}
                placeholder="할 일을 입력하세요"
            />
            <button className="btn-exam" onClick={handleAdd}>추가</button>
        </div>
    );
}


const SimpleTodo = () => {
    const [todos, setTodos] = useState([
        // { id: 1, text: '아침 운동하기', completed: false },
        // { id: 2, text: '책 읽기', completed: true },
        // { id: 3, text: '저녁 요리하기', completed: false }
    ]);

    useEffect(() => {
        // 최초 마운트시 목록 조회후 노출
        const fetchTodos = async () => {
            try {
                const data = await getAllTodos();
                setTodos(data); // 서버 데이터로 상태 세팅
            } catch (error) {
                console.error("Todo 조회 실패:", error);
            }
        };

        fetchTodos();
    }, []);

    // 할 일 추가 (이전코드)
    // const onAdd = (text) => {
    //     if (text.trim() === '') return; // 빈 값 무시
    //     setTodos(prevItem => [
    //         ...prevItem,
    //         {
    //             id: Date.now(), // 임시 부여
    //             text,
    //             completed: false
    //         }
    //     ]);
    // };
    const onAdd = async (text) => {
        if (text.trim() === '') return;
        try {
            const newTodo = await createTodo(text);
            setTodos(prevItems => [
                ...prevItems,
                newTodo
            ]);
        } catch (error) {
            console.error("Todo 생성 실패:", error);
        }
    };

    // 할 일 삭제 (이전코드)
    // const onDel = (id) => {
    //     setTodos(prevItems => prevItems.filter(todo => todo.id !== id));
    // };
    const onDel = async (id) => {
        try {
            await deleteTodo(id);
            setTodos(prevItems => prevItems.filter(todo => todo.id !== id));
        } catch (error) {
            console.error("Todo 삭제 실패:", error);
        }
    };

    const onToggle = async (id, completed) => {
        try {
            await toggleCompleteTodo(id, completed);
            setTodos(items => 
                items.map(todo => 
                    todo.id === id ? { ...todo, completed } : todo
                )
            );
        } catch (error) {
            console.error("Todo 완료 상태 변경 실패:", error);
        }
    };

    return (
        <div className="exam-box simple-todo">
            <h2 className="title">할일 목록</h2>
            <TodoInput onAdd={onAdd} />
            {todos.length === 0 ? (
                <p className="no-data-text">할 일이 없습니다.</p>
            ) : (
                <ul className="todo-list">
                    {todos.map((todo) => (
                        <li key={todo.id}>
                            <TodoItem todo={todo} onDel={onDel} onToggle={onToggle} />
                        </li>
                    ))}
                </ul>
            )}
        </div>
    );
}

export default SimpleTodo;
```

---

## 2. React - Router와 Link

### 2.1 SPA 개념 이해

- **SPA (Single Page Application)**: 단일 페이지 애플리케이션
- 전통적인 웹사이트와 달리 페이지 전체를 새로고침하지 않고 필요한 부분만 업데이트
- 사용자 경험 향상 및 빠른 페이지 전환 가능

#### 전통적인 웹사이트 vs SPA

```bash
전통적인 웹사이트:
사용자 클릭 → 서버에 요청 → 전체 HTML 새로 받음 → 페이지 새로고침

SPA:
사용자 클릭 → JavaScript로 컴포넌트만 교체 → 페이지 새로고침 없음
```

- **장점**
    - 빠른 페이지 전환 (전체 페이지 로드 불필요)
    - 부드러운 사용자 경험
    - 서버 부하 감소 (필요한 데이터만 요청)

- **단점**
    - 초기 로딩 시간이 길 수 있음 (모든 리소스를 한 번에 로드)
    - SEO 최적화가 어려울 수 있음

---

### 2.2 React Router 설치 및 설정

- React Router는 React에서 SPA를 구현하기 위한 라이브러리
- URL에 따라 다른 컴포넌트를 렌더링하여 페이지 전환 효과 구현

#### 설치

```bash
# React Router 설치
npm install react-router-dom
```

#### 기본 설정

```javascript
// src/main.jsx
import React from 'react'
import ReactDOM from 'react-dom/client'
import { BrowserRouter } from 'react-router-dom'
import App from './App.jsx'
import './index.css'

ReactDOM.createRoot(document.getElementById('root')).render(
  <React.StrictMode>
    <BrowserRouter>
      <App />
    </BrowserRouter>
  </React.StrictMode>,
)
```

- `BrowserRouter`로 App 컴포넌트를 감싸서 라우팅 기능 활성화
- `BrowserRouter`는 HTML5 History API를 사용하여 URL을 관리

#### Routes 설정

```javascript
// src/App.jsx
import { Routes, Route } from 'react-router-dom';
import Home from './pages/Home';
import About from './pages/About';
import Contact from './pages/Contact';

function App() {
  return (
    <Routes>
      <Route path="/" element={<Home />} />
      <Route path="/about" element={<About />} />
      <Route path="/contact" element={<Contact />} />
    </Routes>
  );
}

export default App;
```

- `Routes`: 여러 Route를 감싸는 컨테이너
- `Route`: URL 경로와 렌더링할 컴포넌트를 매핑
- `path`: URL 경로
- `element`: 해당 경로에서 렌더링할 컴포넌트

---

### 2.3 Router 관리와 Link 컴포넌트

#### Link 컴포넌트 사용

- `Link` 컴포넌트는 페이지 새로고침 없이 다른 경로로 이동
- 전통적인 `<a>` 태그 대신 사용하여 SPA의 장점 유지

```javascript
// src/components/Navigation.jsx
import { Link } from 'react-router-dom';

const Navigation = () => {
  return (
    <nav>
      <ul>
        <li>
          <Link to="/">홈</Link>
        </li>
        <li>
          <Link to="/about">소개</Link>
        </li>
        <li>
          <Link to="/contact">연락처</Link>
        </li>
      </ul>
    </nav>
  );
};

export default Navigation;
```

#### useNavigate Hook 사용

- 프로그래밍 방식으로 페이지 이동이 필요할 때 사용

```javascript
import { useNavigate } from 'react-router-dom';

const MyComponent = () => {
  const navigate = useNavigate();

  const handleClick = () => {
    // 버튼 클릭 시 /about 페이지로 이동
    navigate('/about');
  };

  const handleGoBack = () => {
    // 이전 페이지로 이동
    navigate(-1);
  };

  return (
    <div>
      <button onClick={handleClick}>소개 페이지로 이동</button>
      <button onClick={handleGoBack}>뒤로 가기</button>
    </div>
  );
};

export default MyComponent;
```

#### 동적 라우팅 (URL 파라미터)

```javascript
// src/App.jsx
import { Routes, Route } from 'react-router-dom';
import UserDetail from './pages/UserDetail';

function App() {
  return (
    <Routes>
      <Route path="/user/:id" element={<UserDetail />} />
    </Routes>
  );
}

export default App;
```

```javascript
// src/pages/UserDetail.jsx
import { useParams } from 'react-router-dom';

const UserDetail = () => {
  const { id } = useParams(); // URL 파라미터 가져오기

  return (
    <div>
      <h2>사용자 상세 정보</h2>
      <p>사용자 ID: {id}</p>
    </div>
  );
};

export default UserDetail;
```

- `:id`는 동적 경로 파라미터
- `useParams()` Hook으로 URL 파라미터 값 가져오기 가능
- 예: `/user/123` → `id = "123"`

#### Link vs useNavigate 비교

- **Link**: 사용자 클릭에 의한 네비게이션 (선언적)
- **useNavigate**: 코드에서 조건부로 이동할 때 사용 (명령적)