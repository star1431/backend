# [ 17주차 - 1208 ]

```bash
    금일 커리큘럼
        ├ 09:00 ~ 12:00 FrontEnd (js 복습, arrow 함수 심화)
        └ 13:00 ~ 18:00 FrontEnd (구조분해할당, 나머지 매개변수, 스프레드 문법) 
```

## 1. js - arrow 함수 심화

> React에서 화살표 함수(arrow function)를 자주 사용

### 1.1 arrow 함수 선언 방식

```javascript
// 기본형태
// 네임 = (매개변수) => { 함수 본문 }
const add = (a, b) => {
    return a + b;
};

// 축약 1 : 리턴 생략
const add = (a, b) => a + b;

// 축약 2 : 매개변수 1개일 때 소괄호 생략
const square = x => x * x;

// 축약 3 : 매개변수 없을 때 빈 소괄호 사용
const greet = () => console.log('Hello!');
```

### 1.2 객체 리터럴 반환

> 객체 리터럴 : 중괄호 `{}` 를 사용하여 객체를 생성하는 표기법

- 객체를 반환할 때는 소괄호로 감싸야 함

```javascript
// 객체 반환 시 소괄호 필요 ({ }),
// { } 만 쓰면 함수 본문으로 인식되고, undefined 반환됨
const createUser = (name, age) => ({
    name: name,
    age: age
    // or 해당 변수명을 그대로 사용 가능
    // name,
    // age
});

console.log(createUser('Alice', 30));
// { name: 'Alice', age: 30 }


// () 생략 시 return 명시하여 작성 가능
const test = (a, b) => {
    return { num1: a, num2: b };
};
console.log(test(1,2));
// { num1: 1, num2: 2 }

```


### 1.2 this 바인딩 차이


> this : 함수가 호출되는 방식에 따라 동적으로 결정되는 특별한 키워드

- this는 함수가 호출되는 방식에 따라 바인딩(연결)되는 객체가 달라짐
- this는 함수가 어디에 속해있는지에 따라 결정되는 것이 아니라, 어떻게 호출되었는지에 따라 결정됨

```javascript
window.name = 'Global name'; // 전역 객체의 name 프로퍼티
const name = 'Local name'; // 전역 변수
const obj = {

  name: 'Alice',
  // 일반 함수
  getName: function() {
    return this.name; // this는 obj를 가리킴
  }
  getNameArrow: () => {
    return this.name; // this는 전역 객체를 가리킴
  }
};

console.log(obj.getName()); // 'Alice'
console.log(obj.getNameArrow()); // 'Global name'
```

- js에서 this는 함수가 호출되는 방식에 따라 바인딩되는 객체가 달라짐
  - 일반 함수 : 호출한 객체에 바인딩
  - 화살표 함수 : 상위 스코프의 this 바인딩을 그대로 사용


#### React에서의 arrow 함수는

- React 컴포넌트 메서드에서 화살표 함수를 사용하면
- this가 컴포넌트 인스턴스에 바인딩되어 편리함
- 즉, React 컴포넌트 내에서 this를 사용해도 안전


## 2. js - 구조 분해 할당

> 디스트럭처링 할당이라고도 하며, 배열이나 객체의 값을 추출하여 개별 변수에 할당하는 문법


### 2.1 객체, 배열 구조분해

```javascript
// 객체 구조분해
const person = {
    name: 'Bob',
    age: 25,
    city: 'New York'
};

const { name, age, city } = person;
console.log(name, age, city); // 'Bob', 25, 'New York'


// 배열 구조분해
const numbers = [10, 20, 30];
const [first, second, third] = numbers;
console.log(first, second, third); // 10, 20, 30
```

- **중첩 구조분해 방식**
    - 객체 안에 객체, 배열 안에 배열도 분해 가능

```javascript
const movieData = {
    title: "인터스텔라",
    year: 2014,
    director: {
        name: "크리스토퍼 놀란",
        nationality: "영국"
    },
    ratings: {
        imdb: 8.6,
        rottenTomatoes: 72
    },
    genres: ["SF", "드라마", "모험"]
};

const {
    title,
    director: {
        name: directorName
    },
    ratings: {
        imdb
    }
} = movieData;
// 다음과 같이 변수에 각각 할당하는 것과 동일
// const title = movieData.title;
// const directorName = movieData.director.name;
// const imdb = movieData.ratings.imdb;


console.log(`영화: ${title}`);
console.log(`감독: ${directorName}`);
console.log(`IMDB 점수: ${imdb}`);
```

### 2.2 기본값 설정, 변수명 변경

```javascript

const user = {
    name: 'Bob',
    age: 25
    // country 프로퍼티 없음
};

// 기본값 설정
const { name, age, country = 'USA' } = user;
console.log(name, age, country); // 'Bob', 25, 'USA'

// 변수명 변경
const { name: userName, age: userAge } = user;
console.log(userName, userAge); // 'Bob', 25
```

### 2.3 요소건너뛰기, 함수 매개변수 분해

```javascript
// 배열 요소 건너뛰기
const numbers = [10, 20, 30, 40];
const [first, , third] = numbers;
console.log(first, third); // 10, 30

// 함수 매개변수 분해
function introduce({ name, age }) {
    // `` 백틱 사용한 문자열 템플릿
    console.log(`내이름은 ${name} 이고, 나이는 ${age} 살입니다.`);
};
```

- **react 컴포넌트 props 분해에도 자주 사용됨**

```javascript
function UserProfile({ name, age, city }) {
    return (
        <div>
            <h1>{name} 님의 프로필</h1>
            <p>나이: {age}</p>
            <p>도시: {city}</p>
        </div>
    );
}
```

## 3. js - 스프레드 연산, 나머지 매개변수

> 스프레드 연산 : ES6 문법으로, (...) 사용하여 배열이나 객체를 펼치는 문법


### 3.1 배열 스프레드

```javascript
const arr1 = [1, 2, 3];
const arr2 = [4, 5, 6];
// 배열 병합
const merged = [...arr1, ...arr2];
console.log(merged); // [1, 2, 3, 4, 5, 6]

// 배열 복사
const copy = [...arr1];
console.log(copy); // [1, 2, 3]

// 배열 요소 추가
const extended = [0, ...arr1, 4];
console.log(extended); // [0, 1, 2, 3, 4]
```


### 3.2 객체 스프레드

```javascript
const productObj = {
    name: 'pen',
    price: 1000
};
// 객체 복사
let copyObj = { ...productObj };

// 속성 추가
copyObj = { ...copyObj, color: 'blue' };

// 속성 수정
copyObj = { ...copyObj, price: 1200 };

console.log(copyObj);
// { name: 'pen', price: 1200, color: 'blue' }
```

- **React에서 활용시**

```javascript
// state 업데이트 시 불변성 유지
const [user, setUser] = useState({ name: "김철수", age: 25 });

// 수정시 새 객체로
setUser({ ...user, age: 26 });

// 리액트에서 user.age = 26; 변경해도 렌더링 안됨
```

### 3.3 나머지 매개변수

- 함수 매개변수로 전달된 인자들을 배열로 모으는 문법

```javascript
function includeAll(a, b, ...rest) {
    console.log(a); // 첫 번째 인자
    console.log(b); // 두 번째 인자
    console.log(rest); // 나머지 인자들을 배열로
}
includeAll(1, 2, 3, 4, 5);
// 1 / 2 / [3, 4, 5]
```


- 구조분해 사용시

```javascript
const numbers = [1, 2, 3, 4, 5];

const [first, second, ...rest] = numbers;

console.log(first); // 1
console.log(second); // 2
console.log(rest); // [3, 4, 5]
```

---

## 4. js Export / Import

> 모듈 시스템에서 코드의 재사용성을 높이기 위해 사용되는 문법

- 모듈로 작성된 js는 html에서 다음과 같이 호출함

```html
<script type="module" src="main.js"></script>
```

### 4.1 Export

- 모듈에서 함수, 변수, 클래스 등을 외부로 내보낼 때 사용
- 네임드 export 와 디폴트 export 가 있음
    - **네임드 export** : **여러 개의 항목**을 내보낼 때 사용
    - **디폴트 export** : **모듈당 하나의 기본 항목**을 내보낼 때 사용

```javascript
// 네임드 export 방식 1 - 선언과 동시에 export
export const pi = 3.14;
export function add(a, b) {
    return a + b;
};

// 네임드 export 방식 2 - 별도 export 구문 사용
const subtract = (a, b) => a - b;
const multiply = (a, b) => a * b;
export {
    subtract,
    multiply
};
```

```javascript
// 디폴트 export 방식 1 - 선언과 동시에 export
export default function greet(name) {
    return `Hello, ${name}!`;
};
```

```javascript
// 디폴트 export 방식 2 - 별도 export 구문 사용
class Person {
    constructor(name, age) {
        this.name = name;
        this.age = age;
    }
}
export default Person;
```

### 4.2 Import

- 다른 모듈에서 내보낸 항목을 가져올 때 사용
- 네임드 import 와 디폴트 import 가 있음
    - **네임드 import** : 중괄호 `{}` 를 사용하여 여러 항목을 가져올 때 사용
    - **디폴트 import** : 중괄호 없이 하나의 기본 항목을 가져올 때 사용

```javascript
// 네임드 import
import { pi, add, subtract } from './mathUtils.js';

console.log(pi); // 3.14
console.log(add(2, 3)); // 5
console.log(subtract(5, 2)); // 3
```

```javascript
// 디폴트 import
import greet from './greet.js';
console.log(greet('Alice')); // 'Hello, Alice!'
```

### 4.3 Import 별칭 (as) 및 전체 (*)

- import 시 이름 충돌을 피하거나 가독성을 높이기 위해 별칭을 사용할 수 있음
- as 키워드를 사용하여 별칭 지정

```javascript
// add 함수를 sum 이라는 이름으로 가져옴
import { add as sum } from './mathUtils.js';
// 모든 항목을 MathUtils 객체로 가져옴
import * as MathUtils from './mathUtils.js';

console.log(sum(2, 3)); // 5
console.log(MathUtils.pi); // 3.14
```

---

## 5. 배열메서드 복습 

- map (변환), filter (조건), find (검색), reduce (누적) 등

### 5.1 map

- 배열의 각 요소에 대해 주어진 함수를 호출한 결과로 새로운 배열을 생성

```javascript
const numbers = [1, 2, 3, 4, 5];
const doubled = numbers.map(num => num * 2);
console.log(doubled); // [2, 4, 6, 8, 10]
```

### 5.2 filter

- 배열의 각 요소에 대해 주어진 조건을 만족하는 요소들로 새로운 배열을 생성

```javascript
const users = [
    { id: 1, name: "짱구", age: 25 },
    { id: 2, name: "철수", age: 30 },
    { id: 3, name: "유리", age: 20 }
];

let adults = users.filter(user => user.age >= 21);
console.log(adults);
// [ { id: 1, name: '짱구', age: 25 },
//   { id: 2, name: '철수', age: 30 } ]
```

### 5.3 find

- 배열의 각 요소에 대해 주어진 조건을 만족하는 첫 번째 요소를 반환

```javascript
const users = [
    { id: 1, name: "짱구", age: 25 },
    { id: 2, name: "철수", age: 30 },
    { id: 3, name: "유리", age: 20 }
];

const user = users.find(user => user.id === 2);
console.log(user); // { id: 2, name: "철수", age: 30 }


const missingUser = users.find(user => user.id === 4);
console.log(missingUser); // undefined
```

### 5.4 reduce

- 배열의 각 요소에 대해 주어진 함수를 호출하여 단일 값으로 누적

```javascript
const numbers = [1, 2, 3, 4, 5];

// 합계
// acc: 누적값, cur: 현재값, 초기값: 0
const sum = numbers.reduce((acc, cur) => 
    acc + cur,
    0 // 초기값
);
/**
 * 실행 흐름
 * Step1: acc = 0, cur = 1 → 1
 * Step2: acc = 1, cur = 2 → 3
 * Step3: acc = 3, cur = 3 → 6
 * Step4: acc = 6, cur = 4 → 10
 * Step5: acc = 10, cur = 5 → 15
 */
console.log(sum); // 15


// 최대값
// acc: 누적값, cur: 현재값, 초기값: numbers[0]
const max = numbers.reduce((acc, cur) => 
    (cur > acc ? cur : acc),
    numbers[0] // 초기값
);
/**
 * 실행 흐름 (초기값이 numbers[0]이므로 처음 cur은 2부터 시작)
 * Step1: acc = 1, cur = 2 | cur > acc ? → 2
 * Step2: acc = 2, cur = 3 | cur > acc ? → 3
 * Step3: acc = 3, cur = 4 | cur > acc ? → 4
 * Step4: acc = 4, cur = 5 | cur > acc ? → 5
 * 최종 결과: 5
 */
console.log(max); // 5

```


