# [ 9주차 - 1014 ] 스터디 내용

```bash
    금일 커리큘럼
        ├ 09:00 ~ 14:00 backend 프로그래밍 (Spring Framework 복습)
        └ 14:00 ~ 18:00 backend 프로그래밍 (컴포넌트와 오토와이어드, 컴포넌트스캔과 컨피그레이션)
```

## 1. 컴포넌트와 오토와이어드

### @Component 이해

> 스프링이 관리하는 빈(Bean) **등록**

* `@Component`는 클래스를 스프링의 **빈(Bean) 등록하는 역할**

* 스프링에선 애플리케이션 컨텍스트(ApplicationContext)를 통해 객체를 관리하며, 등록된 빈을 요청시 사용할수 있도록 함.
* `@ComponentScan`을 통해 지정한 패키지 내에서 컴포넌트형 어노테이션이 붙은 클래스들 Bean으로 등록 가능

```java
// file: Dice.java
package sample.bean;
import org.springframework.stereotype.Component;

@Component // 해당 클래스를 스프링 빈(Bean) 등록
public class Dice {
    private int face;

    public Dice() {
        this.face = 6; // 기본값 설정
        System.out.println("Dice() 생성!");
    }
    public Dice(int face) {
        this.face = face;
        System.out.println("Dice(int) 생성!");
    }

    public int getFace() { return face;}
    public int runDice() { return (int) (Math.random() * face) + 1;}
}
// ----------------------------------------------------
// file: MyBeanConfig2.java
package sample.config;
import org.springframework.context.annotation.ComponentScan;

@ComponentScan(basePackages = "sample") // sample 패키지 이하의 모든 컴포넌트형 어노테이션을 스캔
public class MyBeanConfig2 {}

// ----------------------------------------------------
// file: runExam03.java
package sample.run;
import org.springframework.context.ApplicationContext;
import org.springframework.context.annotation.AnnotationConfigApplicationContext;
import sample.config.MyBeanConfig2;

public class RunExam03 {
    public static void main(String[] args) {
        System.out.println("스프링 등록 전 ----");
        ApplicationContext context = new AnnotationConfigApplicationContext(MyBeanConfig2.class);
        System.out.println("스프링 등록 후 ----");
    }
}
```

```bash
# 실행 결과
스프링 등록 전 ----
Dice() 생성!
스프링 등록 후 ----
```

### @Autowired 이해

> 스프링이 관리하는 빈(Bean)을 **자동으로 주입**

* `@Autowired` 은 스프링이 관리하는 **빈(Bean)을 주입하는 역할**
* `@Autowired` 어노테이션은 **필드, 생성자, 메서드** 등 붙여서 자동으로 해당 타입의 Bean을 찾아 주입 함.


```java
// file: Player.java
package sample.bean;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Component;


@Component
public class Player {
    private String name;
    private final Dice dice;

    public Player() {
        this.dice = new Dice(); // 직접 생성 (스프링 빈 아님)
        System.out.println("Player() 실행");
    }

    // 생성자 주입 - 권장방식
    @Autowired
    public Player(Dice dice) {
        this.dice = dice;
        System.out.println("Player(Dice) 실행");
    }

    public void setName(String name) {
        this.name = name;
    }

    // @Autowired
    // public void setDice(Dice dice) {
    //     this.dice = dice;
    // }

    public void play() {
        System.out.printf("[%s]님이 주사위 던져서 [%d] 나왔습니다. (주사위면: %d)%n", name, dice.runDice(), dice.getFace());
    }
}

// ----------------------------------------------------
// file: runExam03.java
package sample.run;
import org.springframework.context.ApplicationContext;
import org.springframework.context.annotation.AnnotationConfigApplicationContext;
import sample.bean.Player;
import sample.config.MyBeanConfig2;

public class RunExam03 {
    public static void main(String[] args) {
        ApplicationContext context = new AnnotationConfigApplicationContext(MyBeanConfig2.class);
        Player player = context.getBean(Player.class);
        player.setName("star1431");
        player.play();
    }
}
```

```bash
# 실행 결과
Dice() 생성!
Player(Dice) 실행 # @Autowired 생성자 주입이 반영됨.
[star1431]님이 주사위 던져서 [3] 나왔습니다. (주사위면: 6)
```


---


## 2. 컴포넌트스캔과 컨피그레이션

> Spring에서 빈(Bean)을 등록하는 두 가지 주요 방식임

* `@ComponentScan` : 패키지 내의 컴포넌트형 어노테이션이 붙은 클래스를 스캔하여 빈 등록
* `@Configuration` : 수동으로 빈을 정의하고 등록하는 설정 클래스


### 컴포넌트 스캔 방식

* `@Component`, `@Service`, `@Repository`, `@Controller` 등 어노테이션 붙은 클래스 사용됨.


| 어노테이션 | 주로 쓰이는 계층 | 의미 / 역할 | 부가 기능 |
|-----------|-----------------|------------|-----------|
| @Component | 모든 계층 (공통) | 범용적인 컴포넌트 표시용 | 부가 기능 없음 |
| @Service | 비즈니스 로직 계층 | 비즈니스 로직을 담당하는 클래스 | 부가 기능 없음. 의미만 명시 |
| @Repository | DAO 계층 | DB 접근 담당 클래스 | 스프링이 데이터 접근 예외(DataAccessException)<br>로 자동 변환해줌 |
| @Controller | 웹 계층 | 클라이언트의 요청을 처리하고 View 반환 | DispatcherServlet이<br>HTTP 요청/응답 처리에 연결 |

* 컴포넌트 스캔전 Configuration 어노테이션 필요함
    -  why ?  스프링에게 설정 클래스라고 명시하기 위해

```java
// file: UserConfig.java
import org.springframework.context.annotation.Configuration;
import org.springframework.context.annotation.ComponentScan;

@Configuration // 설정클래스라도 식별시킴
@ComponentScan(basePackages = "org.example.iocexam") // 해당 루트 내 컴포넌트 스캔함
public class UserConfig { }

// 베이스 패키지 내 모든 컴포넌트타입의 어노테이션들 스캔 후 빈 등록
// UserDAOImpl.java     <- @Repository
// UserServiceImpl.java <- @Service
// UserController.java  <- @Controller
```

```java
// file: UserDAOImpl.java  
@Repository
public class UserDAOImpl implements UserDAO {
    // 구현 코드
}

// file: UserServiceImpl.java  
@Service
public class UserServiceImpl implements UserService {
    @Autowired
    private UserDAO userDAO;
    // 구현 코드
}

// file: UserController.java
@Controller
public class UserController {
    @Autowired
    private UserService userService;
    // 구현 코드
}
```

### 컨피그레이션 방식

* 클래스들 각 어노테이션 없이 `@Configuration`과 `@Bean` 어노테이션으로 빈(Bean) 등록

```java
// file: UserConfig.java
import org.example.iocexam.controller.UserController;
import org.example.iocexam.repository.UserDAO;
import org.example.iocexam.repository.UserDAOImpl;
import org.example.iocexam.service.UserService;
import org.example.iocexam.service.UserServiceImpl;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

@Configuration 
public class UserConfig {

    @Bean
    public UserDAO userDAO() {
        return new UserDAOImpl();
    }

    @Bean
    public UserService userService() {
        return new UserServiceImpl(userDAO());
    }

    @Bean
    public UserController userController() {
        return new UserController(userService());
    }
}
```

### 각 방식의 차이


| 구분 | 컴포넌트 스캔 | 컨피그레이션 |
|------|--------------|--------------|
| 등록 방식 | 자동 스캔 | 수동 정의 |
| 클래스 어노테이션 | 필요 (@Service, @Repository 등) | 불필요 |
| 의존성 주입 | @Autowired 사용 | 메서드 호출로 직접 주입 |
| 장점 | 간편함, 자동화 | 명시적 제어, 복잡한 설정 가능 |
| 단점 | 제어 한계 | 코드 량 증가 |

**실무 활용 팁**
- 컴포넌트 스캔: 일반적인 애플리케이션 개발 시 권장
- 컨피그레이션: 외부 라이브러리 빈 등록, 복잡한 초기화 로직이 필요한 경우

---

## 3. @Qualifier 이해

* `@Autowired`로 주입할 때, 동일 타입 여러개인 경우 어떤 빈을 주입할지 모호함
   - NoUniqueBeanDefinitionException 발생
* `@Qualifier` 어노테이션으로 특정 빈 이름 지정하여 주입 가능

```java
@Component
public class Game {
    private String name;
    private Dice normalDice;
    private Dice fastDice;

    @Autowired
    public Game(
            @Qualifier("dice6") Dice dice6,
            @Qualifier("dice12") Dice dice12) {
        this.normalDice = dice6;
        this.fastDice = dice12;
        System.out.println("Game(Dice) 실행");
    }

    public void setName(String name) {
        this.name = name;
    }

        public void play(String type) {
        Dice selected;
        if ("dice12".equalsIgnoreCase(type)) {
            selected = fastDice;
        } else {
            selected = normalDice;
        }
        int result = selected.runDice();
        System.out.printf("[%s] %d면체 주사위 결과: %d%n", type, selected.getFace(), result);
    }

    // next code...
}


// ----------------------------------------------------

@Component("dice6")
public class NormalDice extends Dice {
    public NormalDice() {
        super(6); // 6면체 주사위
    }
    
    @Override
    public int runDice() {
        return (int) (Math.random() * getFace()) + 1;
    }
}

@Component("dice12")
public class FastDice extends Dice {
    public FastDice() {
        super(12); // 12면체 주사위
    }

    @Override
    public int runDice() {
        return (int) (Math.random() * getFace()) + 1;
    }
}
```

---

## etc

### 스프링 빈 등록 과정

```bash
어플리케이션 컨텍스트(ApplicationContext) 생성
    │
    ↓
빈(Bean) 정의 수집 과정
    ├─ @ComponentScan으로 지정된 패키지 스캔
    │   ├─ @Component 클래스 발견
    │   ├─ @Service 클래스 발견  
    │   ├─ @Repository 클래스 발견
    │   ├─ @Controller 클래스 발견
    │   └─ @Configuration 클래스 발견
    │
    └─ @Configuration 클래스 발견시, 내부 @Bean 메서드 처리
    │
    ↓
빈(Bean) 등록 및 인스턴스 생성
    │
    ↓
@Autowired가 붙은 의존성 관계 분석
    ├─ 생성자 주입 우선 확인 # 생성자가 하나면 @Autowired 생략 가능
    ├─ 필드 @Autowired 주입 여부
    └─ 세터 @Autowired 주입 여부
    │
    ↓
의존성 주입 (DI) 실행
    │
    ↓
빈 초기화 완료 및 사용 준비
    │
    ↓
getBean()으로 빈 요청 시, 등록된 빈 반환
```

### 생성자 주입 관련 주의사항

> 생성자주입 : 생성자가 하나인 경우 @Autowired 생략 가능 (권장방식)

```java
@Component
public class Player {
    private final Dice dice;
    
    // @Autowired 생략 가능 (생성자가 하나뿐이므로)
    public Player(Dice dice) {
        this.dice = dice;
    }
    // next code...
}
```

> 생성자주입 : 생성자가 여러개인 경우 @Autowired 필수

```java
@Component
public class Player {
    private final Dice dice;
    
    public Player() {
        this.dice = new Dice();
    }
    
    @Autowired // 반드시 명시해야 함
    public Player(Dice dice) {
        this.dice = dice;
    }
    // next code...
}
```