# [ 2주차 - 0822 ] 스터디 내용

```bash
    금일 커리큘럼
        ├ 09:00 ~ 12:00 자바 프로그래밍 기초 (생성자, 상속, 오버라이딩, 오버로딩)
        └ 13:00 ~ 18:00 자바 프로그래밍 기초
```


## 1. 생성자 (Constructor)

* 객체가 생성될 때 자동으로 호출되는 특별한 메서드  
* 클래스 이름과 동일하며, 반환 타입이 없음  
* 객체의 초기값 설정에 사용됨

<br>

### 기본 생성자
* 매개변수가 없는 생성자
```java
class User {
    String name;
    int age;

    // 기본 생성자
    public User() {
        name = "홍길동";
        age = 0;
    }
}

public class UserExam {
    public static void main(String[] args) {
        User u1 = new User();
        System.out.println(u1.name);
    }
}
```
```bash
# 출력결과
홍길동
```

<br>

### 매개변수 생성자
* 객체 생성 시 원하는 값으로 초기화 가능
```java
class User {
    String name;
    int age;

    // 매개변수 생성자
    public User(String name, int age) {
        this.name = name;
        this.age = age;
    }
}

public class UserExam {
    public static void main(String[] args) {
        User u2 = new User("철수", 25);
        System.out.println(u2.name);
        System.out.println(u2.age);
    }
}
```
```bash
# 출력결과
철수
25
```

<br>

### 기본 생성 + 매개변수 생성 사용시
```java
class User {
    String name;
    int age;

    // 기본 생성자
    public User() {
        this("이름없음", -1); // this() -> 매개변수 없으면 디폴트값 설정, 사용.
    }
    public User(String name) {
         this(title, 0);
         // or
         // this.name = name;
    }
    public User(String name, int age) {
        this.name = name;
        this.age = age;
    }
}

public class UserExam {
    public static void main(String[] args) {
        User u1 = new User();
        User u2 = new User("영희");
        User u3 = new User("민수", 30);

        System.out.println("u1 : " + u1.name + "," + u1.age);
        System.out.println("u2 : " + u2.name + "," + u2.age);
        System.out.println("u3 : " + u3.name + "," + u3.age);
    }
}
```
```bash
# 실행 결과
u1 : 이름없음,-1
u2 : 영희,0
u3 : 민수,30
```

> [!TIP]
> * 생성자는 객체가 생성될 떄 단 한번만 호출됨 - 임의 호출 불가능!
> * `this`: 현재 인스턴스를 가리키는 참조 변수 (자기 자신)
> * `this()`: 같은 클래스의 다른 생성자를 호출할 때 사용
> * `this()`는 반드시 생성자의 첫 번째 줄에서만 사용할 수 있음

---

## 2. 상속 (inheritance)

> 부모 클래스의 필드와 메소드를 자식 클래스가 물려받는 것

* 부모 자식간 `is-a` ,`kind-of`로 관계를 표현함.
* 코드 `재사용` 및 `확장성`에 용이하다.

```java
// 부모 클래스 (다른 패키지)
// package 경로A;
public class Animal {
    protected String name;
    protected int age;

    // 자식 상속에선 super()로 접근
    public Animal(String name, int age) {
        this.name = name;
        this.age = age;
    }

    public void info() {
        System.out.println("동물이름: " + name);
        System.out.println("동물나이: " + age);
    }
}
```
```java
// 자식 클래스와 사용 예시 (현재 패키지)
// package 경로B;
// import 경로A.Animal;

class Dog extends Animal {
    private String breed;

    public Dog(String name, int age, String breed) {
        super(name, age); // 부모 생성자 호출
        this.breed = breed;
    }

    public void showBreed() {
        System.out.println("견종: " + breed);
    }
}

public class AnimalExam {
    public static void main(String[] args) {
        Dog dog = new Dog("초코", 3, "슈나우저");
        dog.info();        // 부모 메서드 사용
        dog.showBreed();   // 자식 메서드 사용
    }
}
```
```bash
# 실행결과
동물이름: 초코
동물나이: 15
견종: 슈나우저
```

---

## 3. 메소드 오버라이딩

**오버라이딩(Overriding)**

* 부모 클래스에서 정의한 메서드 -> 자식 클래스에서 **재정의**함
* `메서드 이름`, `매개변수`, `반환타입` 모두 **동일**해야 함
* 오버라이딩 사용시 `@Override` 어노테이션 사용 권장

```java
class Animal {
    public void sound() {
        System.out.println("동물이 소리를 낸다");
    }
}

class Dog extends Animal {
    // 자식클래스에서 sound 재정의 됨
    @Override
    public void sound() {
        System.out.println("멍멍!");
    }
}

// 사용 예시
Animal a = new Dog();
a.sound();
```
```bash
# 실행 결과
멍멍!
```

## 4. 메소드 오버로딩

* **오버로딩(Overloading)** <br>
  같은 이름의 메서드를 **매개변수의 타입/개수**만 다르게 여러 개 정의함.

```java
class Calc {
    public int add(int a, int b) {
        return a + b;
    }
    public double add(double a, double b) {
        return a + b;
    }
    public int add(int a, int b, int c) {
        return a + b + c;
    }
}

// 사용 예시
Calc calc = new Calc();
calc.add(1, 2);         // int 버전
calc.add(1.5, 2.5);     // double 버전
calc.add(1, 2, 3);      // 3개 int 버전
```


