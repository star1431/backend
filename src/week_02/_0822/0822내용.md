# [ 2주차 - 0822 ] 스터디 내용

```bash
    금일 커리큘럼
        ├ 09:00 ~ 12:00 자바 프로그래밍 기초 (기본 생성자, 매개변수 생성자, this)
        └ 13:00 ~ 18:00 자바 프로그래밍 기초 (메서드체이닝, 패키지와 import, static 키워드)
```


## 1. 생성자 (Constructor)

* 객체가 생성될 때 자동으로 호출되는 특별한 메서드  
* 클래스 이름과 동일하며, 반환 타입이 없음  
* 객체의 초기값 설정에 사용됨

<br>

### 기본 생성자
* 매개변수가 없는 생성자
```java
class User {
    String name;
    int age;

    // 기본 생성자
    public User() {
        name = "홍길동";
        age = 0;
    }
}

public class UserExam {
    public static void main(String[] args) {
        User u1 = new User();
        System.out.println(u1.name);
    }
}
```
```bash
# 실행 결과
홍길동
```

<br>

### 매개변수 생성자
* 객체 생성 시 원하는 값으로 초기화 가능
```java
class User {
    String name;
    int age;

    // 매개변수 생성자
    public User(String name, int age) {
        this.name = name;
        this.age = age;
    }
}

public class UserExam {
    public static void main(String[] args) {
        User u2 = new User("철수", 25);
        System.out.println(u2.name);
        System.out.println(u2.age);
    }
}
```
```bash
# 실행 결과
철수
25
```

<br>

### 기본 생성 + 매개변수 생성 사용 (오버로딩 활용)
```java
class User {
    String name;
    int age;

    // 기본 생성자
    public User() {
        this("이름없음", -1); // this() -> 매개변수 없으면 디폴트값 설정, 사용.
    }
    public User(String name) {
         this(title, 0);
         // or
         // this.name = name;
    }
    public User(String name, int age) {
        this.name = name;
        this.age = age;
    }
}

public class UserExam {
    public static void main(String[] args) {
        User u1 = new User();
        User u2 = new User("영희");
        User u3 = new User("민수", 30);

        System.out.println("u1 : " + u1.name + "," + u1.age);
        System.out.println("u2 : " + u2.name + "," + u2.age);
        System.out.println("u3 : " + u3.name + "," + u3.age);
    }
}
```
```bash
# 실행 결과
u1 : 이름없음,-1
u2 : 영희,0
u3 : 민수,30
```

> [!TIP]
> * 생성자는 객체가 생성될 떄 단 한번만 호출됨 - 임의 호출 불가능!

### this 와 메소드 체이닝

```java
public class Student {
    private String name;
    private int grade;

    public Student(String name, int grade) {
        this.name = name;
        this.grade = grade;
    }

    public Student setGrade(int grade) {
        this.grade = grade;
        return this;
    }

    public Student setName(String name) {
        this.name = name;
        return this;
    }

    public void printInfo() {
        System.out.println("학생 이름: " + this.name);
        System.out.println("학년: " + this.grade);
    }
}

public class StudentTest {
    public static void main(String[] args) {
        Student s = new Student("홍길동", 2);

        // 메서드 체이닝
        s.setGrade(3)
         .setName("영희")
         .printInfo();

         // or
        s.setGrade(5).setName("철수").printInfo();
    }
}
```
```bash
# 실행 결과
학생 이름: 영희
학년: 3
학생 이름: 철수
학년: 5
```

> [!TIP]
> * `this`: 현재 인스턴스를 가리키는 참조 변수 (자기 자신)
> * `this()`: 같은 클래스의 다른 생성자를 호출할 때 사용
> * `this()`는 반드시 생성자의 첫 번째 줄에서만 사용할 수 있음

---

## 2. packge 와 import

* 패키지
    * 관련된 클래스를 디렉토리기준 그룹화
    * 클래스의 충돌 방지와 관리 목적
    * 도메인으로 정의시 역순
        - jbc.dev.com -> com.dev.jbc

```bash
# 예시 도메인 : com.java.jbc
(root) com 
    ㄴ dev
        ㄴ jbc
            ㄴ module
            ㄴ common
```

### package 선언
```java
// 현재 root : com/dev/jbc/common/
package com.dev.jbc.common;
public class Dice {
    protected int face = 6;
    private int eye;

    public void roll() {
        eye = (int)(Math.random() * face) + 1;
    }

    public void setEye(int eye) {
        this.eye = eye;
    }
    
    public int getEye() {
        return eye;
    }
}
```
> [!TIP]
> 패키지 명명 규칙 (폴더명)
> * 숫자가 앞에 올 수 없음
> * 예약어 사용 금지
> * 모두 소문자 사용 
> * 특문은 `_` 만 허용

### import 선언
```java
// 현재 root : com/dev/jbc/
package com.dev.jbc;
import com.dev.jbc.common.Dice;

public class DiceExam {
    public static void main(String[] args) {
        Dice dice = new Dice();

        dice.roll();
        System.out.println("주사위 실행 : " + dice.getEye());
        dice.setEye(0);

        int cnt = 10, choice = 5, total = 0;
        for (int i = 0; i < cnt; i++) {
            dice.roll();
            if(dice.getEye() == choice) total++;
        }

        System.out.printf("주사위 %d번 굴려서 %d 나온 횟수 : %d%n", cnt, choice, total);
    }
}
```

### import 사용 규칙
```java
// 단일형식
import java.util.Scanner;

// 와일드 (전체호출)
import java.util.*;

// 스태틱 멤버 사용 (jav 8 JVM)
import static java.lang.Math.random;

public class Exam {
    public static void main(String[] args) {
        int ranNum = (int)(random()*10) + 1; // (int)(Math.random()*10) + 1
    }
}
```



> [!WARNING]
> 다른 패키지에 같은 클래스명이 있을 경우 <br>
> **패키지명을 포함해서 클래스 전체 경로로 사용**해야 함

```java
import comon.User;
import module.User;
common.User user1 = new common.User();
module.User user2 = new module.User();
```

---

## 3. static 키워드


### 자바 메모리
```bash
# Java 7 JVM 메모리 구조

[Java Heap]
 ├─ Eden
 ├─ Survivor
 ├─ Old
 └─ PermGen

[Native Memory]
 ├─ C heap
 └─ Thread Stack

----------------------------------------

# Java 8 JVM 메모리 구조

[Java Heap]
 ├─ Eden
 ├─ Survivor
 └─ Old

[Metaspace]   # PermGen 대신 Metaspace로 변경됨

[Native Memory]
 ├─ C heap
 └─ Thread Stack
```


```bash
# 자바 클래스 로딩 및 인스턴스 생성 흐름도

[Class Loader 생성]
        │
        └─ Heap: [Id]   # 클래스 로더 인스턴스가 Heap에 생성됨
        │
        ▼
[클래스 X 로드]
        │
        ├─ Metaspace: [Metadata for X]
        │
        └─ Heap: [j.lClass instance for X]
                   │
                   ├─ a = new X()
                   └─ b = new X()
        │
        ▼
[클래스 Y 로드]
        │
        ├─ Metaspace: [Metadata for X], [Metadata for Y]
        │
        └─ Heap: [j.lClass instance for X] (a, b)
                [j.lClass instance for Y] (c = new Y())
```

클래스는 로딩될 때 메타스페이스에 클래스가 로딩된다.

### 메모리 저장 위치 (java 8 이후)
* static 변수는 Heap 영역에 저장
* Class 메타데이터는 Metaspace(Native Memory)에 저장
* PermGen 영역이 제거되어 `OutOfMemoryError: PermGen space` 문제 해결


### 기본적인 메모리 개념
* `new 연산자`를 사용할 때마다 메모리에 `인스턴스`가 생성됨.
* 인스턴스는 더 이상 참조되는 것이 없을 때, 나중에 `가비지 컬렉션` 됨.
* static한 필드는 클래스가 로딩될 때 `딱 한번` 메모리에 올라가고 초기화.
* 클래스 메소드는 `클래스명.메소드명()` 으로 사용가능.
* `메소드 안에 선언된 변수`들은 메소드가 실행될 때 메모리에 생성되었다가, `메소드가 종료`될 때 사라짐.


### static 필드 , 메소드
```java
package week_02._0822;

public class StaticExam {
    int insVal;
    static int stVal;

    public void insMethod01(){
        // 스태틱 아닌 메소드인 경우 둘다 접근 가능
        System.out.println(insVal);
        System.out.println(stVal);
    }

    public void insMethod02(){
        insMethod01();
        stMethod01();
        stMethod02();
    }
    public static void stMethod01(){
        // static 메소드 인 경우 static한 필드만 접근 가능!!
        // System.out.println(insVal);
        System.out.println(stVal);
    }
    public static void stMethod02(){
        stMethod01();
        // insMethod01();
    }

    public static void main(String[] args) {
        stVal = 100;
        System.out.println(stVal);
        stMethod01();

        // 인스턴스 필드, 메서드는 객체가 반드시 인스턴스화 된 후에 쓸수있다.
        // System.out.println(insVal);
        // insMethod01();
    }
}
```

```java
class Student {
    // 인스턴스 필드
    String name;
    int score;

    // 클래스 필드 (모든 인스턴스가 공유)
    static int totalStudents = 0;
    static int totalScore = 0;

    // 생성자
    public Student(String name, int score) {
        this.name = name;
        this.score = score;
        totalStudents++;
        totalScore += score;
    }

    // 인스턴스 메소드
    public void displayInfo() {
        System.out.println(name + ": " + score + "점");
    }

    // 클래스 메소드
    public static double getAverage() {
        if(totalStudents == 0) return 0;
        return (double)totalScore / totalStudents;
    }

    public static void displayStatistics() {
        System.out.println("전체 학생 수: " + totalStudents);
        System.out.println("전체 점수 합: " + totalScore);
        System.out.println("평균 점수: " + getAverage());
    }
}

public class StudentTest {
    public static void main(String[] args) {
        // static 메소드는 객체 생성 없이 호출 가능
        Student.displayStatistics();
        System.out.println("-".repeat(5));

        Student s1 = new Student("학생1", 85);
        Student s2 = new Student("학생2", 92);
        Student s3 = new Student("학생3", 78);

        s1.displayInfo();
        s2.displayInfo();
        s3.displayInfo();
        System.out.println("-".repeat(5));

        // 클래스명으로 static 메소드 호출
        Student.displayStatistics();
    }
}
```

```bash
# 실행 결과
전체 학생 수: 0
전체 점수 합: 0
평균 점수: 0.0
-----
학생1: 85점
학생2: 92점
학생3: 78점
-----
전체 학생 수: 3
전체 점수 합: 255
평균 점수: 85.0
```


---
<!-- 
## 2. 상속 (inheritance)

> 부모 클래스의 필드와 메소드를 자식 클래스가 물려받는 것

* 부모 자식간 `is-a` ,`kind-of`로 관계를 표현함.
* 코드 `재사용` 및 `확장성`에 용이하다.

```java
// 부모 클래스 (다른 패키지)
// package 경로A;
public class Animal {
    protected String name;
    protected int age;

    // 자식 상속에선 super()로 접근
    public Animal(String name, int age) {
        this.name = name;
        this.age = age;
    }

    public void info() {
        System.out.println("동물이름: " + name);
        System.out.println("동물나이: " + age);
    }
}
```
```java
// 자식 클래스와 사용 예시 (현재 패키지)
// package 경로B;
// import 경로A.Animal;

class Dog extends Animal {
    private String breed;

    public Dog(String name, int age, String breed) {
        super(name, age); // 부모 생성자 호출
        this.breed = breed;
    }

    public void showBreed() {
        System.out.println("견종: " + breed);
    }
}

public class AnimalExam {
    public static void main(String[] args) {
        Dog dog = new Dog("초코", 3, "슈나우저");
        dog.info();        // 부모 메서드 사용
        dog.showBreed();   // 자식 메서드 사용
    }
}
```
```bash
# 실행 결과
동물이름: 초코
동물나이: 15
견종: 슈나우저
```

---

## 3. 메소드 오버라이딩

**오버라이딩(Overriding)**

* 부모 클래스에서 정의한 메서드 -> 자식 클래스에서 **재정의**함
* `메서드 이름`, `매개변수`, `반환타입` 모두 **동일**해야 함
* 오버라이딩 사용시 `@Override` 어노테이션 사용 권장

```java
class Animal {
    public void sound() {
        System.out.println("동물이 소리를 낸다");
    }
}

class Dog extends Animal {
    // 자식클래스에서 sound 재정의 됨
    @Override
    public void sound() {
        System.out.println("멍멍!");
    }
}

// 사용 예시
Animal a = new Dog();
a.sound();
```
```bash
# 실행 결과
멍멍!
```

## 4. 메소드 오버로딩

* **오버로딩(Overloading)** <br>
  같은 이름의 메서드를 **매개변수의 타입/개수**만 다르게 여러 개 정의함.

```java
class Calc {
    public int add(int a, int b) {
        return a + b;
    }
    public double add(double a, double b) {
        return a + b;
    }
    public int add(int a, int b, int c) {
        return a + b + c;
    }
}

// 사용 예시
Calc calc = new Calc();
calc.add(1, 2);         // int 버전
calc.add(1.5, 2.5);     // double 버전
calc.add(1, 2, 3);      // 3개 int 버전
```

 -->
