# [ 2주차 - 0821 ] 스터디 내용

```bash
    금일 커리큘럼
        ├ 09:00 ~ 12:00 자바 프로그래밍 기초 (다차원배열, 객체지향 기초)
        └ 13:00 ~ 18:00 자바 프로그래밍 기초 (클래스와 객체, 필드, 메서드)
```



## 1. 다차원 배열
> 배열 안에 또 다른 배열이 들어있는 형태

- 행(row)과 열(column)로 이루어진 표(테이블)처럼 데이터를 저장할 수 있음
- 예시: [학생 점수표], [좌석 배치도] 등

### 선언 방법
```java
// 3행 4열의 2차원 배열
int[][] arr = new int[3][4];
// 초기화 정의
int[][] arr = {
    {1, 2, 3, 4},
    {-1, -2, -3, -4},
    {0, 0}
}
```

### 출력 방법
```java
int[][] arr = new int[][] {
        {1, 2, 3},  // arr[0][] -> [0][0] = 1, [0][1] = 2, [0][2] = 3,
        {4, 5, 6},  // arr[1][] -> [1][0] = 4, [1][1] = 5, [2][2] = 6,
        {7, 8}      // arr[2][] -> [2][0] = 7, [2][1] = 8,
};

// [출력 방법 1] deepToString
System.out.println("arr : " + Arrays.deepToString(arr));

// [출력 방법 2] for문
for (int i = 0; i < arr.length; i++) {
    System.out.printf("arr[%d] : [", i);
    for (int j = 0; j < arr[i].length; j++) {
        if(j == (arr[i].length - 1)) System.out.printf("%d]", arr[i][j]);
        else System.out.printf("%d, ", arr[i][j]);
    }
    System.out.print("\n");
}
```
```bash
# [출력 방법 1] 실행결과
arr : [[1, 2, 3], [4, 5, 6], [7, 8]]

# [출력 방법 2] 실행결과
arr0[0] : [1, 2, 3]
arr0[1] : [4, 5, 6]
arr0[2] : [7, 8]
```

### 실용예제
```java
    public void exam01() {
        /*
         *  === 성적표 ===
            이름  국어  영어  수학  과학  총점  평균
            --------------------------------------------------
            김철수 90  85  88  92  355 88.8
            이영희 85  90  95  88  358 89.5
            박민수 78  82  85  90  335 83.8
         */

        String[] attrVal = { "국어", "영어", "수학", "과학" };
        String[] stuName = { "김철수", "이영희", "박민수" };
        int[][] scoreArr = {
                {90, 85, 88, 92},
                {85, 90, 95, 88},
                {78, 82, 85, 90}
        };

        // 헤드 및 속성 출력
        System.out.println("=== 성적표 ===");
        System.out.print("이름  \t");
        for (String val : attrVal) {
            System.out.print(val + "\t");
        }
        System.out.println("총점\t평균");
        System.out.println("-".repeat(50)); // (n)개만큼 복사

        // 데이터 행 출력
        for (int i = 0; i < stuName.length; i++) {
            System.out.print(stuName[i] + "\t");
            int sum = 0;
            double avg = 0;
            // 총합계산
            for (int j = 0; j < scoreArr[i].length; j++) {
                System.out.print(scoreArr[i][j] + "\t");
                sum += scoreArr[i][j];
            }
            // 평균계산
            avg = (double) sum / attrVal.length;
            // 마지막 출력
            System.out.printf("%d\t%.1f\n", sum, avg);
        }
    }
```
```bash
# 실행 결과
=== 성적표 ===
이름    국어    영어    수학    과학    총점    평균
--------------------------------------------------  
김철수  90      85      88      92      355     88.8
이영희  85      90      95      88      358     89.5
박민수  78      82      85      90      335     83.8
```

---


## 2. 객체지향 기초
> 객체지향 프로그래밍(Object-Oriented Programming, OOP) 정의 <br>
> 컴퓨터 프로그래밍의 패러다임 중 하나이다.<br>
> 객체 지향 프로그래밍은 컴퓨터 프로그램을 명령어의 목록으로 보는 시각에서 벗어나 <br>
> 여러 개의 독립된 단위, 즉 `객체들의 모임`으로 파악하고자 하는 것이다. <br>
> 각각의 객체는 `메시지를 주고받고, 데이터를 처리`할 수 있다.

<br>

### 객체 지향 설계의 5원칙 = 솔리드 (SOLID)

* **S**RP(Single Responsibility Principle): 단일 책임 원칙
    - 객체는 오직 하나의 책임을 가짐.

* **O**CP(Open Closed Priciple): 개방 폐쇄 원칙
    - ✅ ``확장``에 대해서는 개방적 
    - ❌ ``수정``에 대해서는 폐쇄적 

* **L**SP(Listov Substitution Priciple): 리스코프 치환 원칙
    - 자식 클래스는 언제나 자신의 부모 클래스를 `대체 가능`

* **I**SP(Interface Segregation Principle): 인터페이스 분리 원칙
    - 목적과 용도에 따른 인터페이스 분리

* **D**IP(Dependency Inversion Principle): 의존 역전 원칙
    -  객체에서 어떤 Class를 참조해서 사용해야하는 상황이 생긴다면, <br>
        그 Class를 직접 참조하는 것이 아니라 <br> 
        그 대상의 상위 요소(추상 클래스 or 인터페이스)로 참조
```java
// 변수 타입을 고수준의 모듈인 인터페이스 타입으로 선언하여 저수준의 모듈을 할당
List<String> myList = new ArrayList()<>;
    
Set<String> mySet = new HashSet()<>;

Map<int, String> myMap = new HashMap()<>;
```
> 출처 : https://inpa.tistory.com/entry/

<br>

---

## 3. 클래스와 객체

| 개념 | 설명 | 비유 |
|:---|:---|:---|
| 클래스(class) | 객체를 만들기 위한 설계도, 틀 | 자동차 설계도 |
| 객체(object) | 클래스로부터 만들어진 실제 데이터(인스턴스) | 공장에서 만들어진 자동차 |
| 인스턴스(instance) | 클래스가 메모리에 생성된 상태 | 등록되어 실제로 존재하는 자동차(차고에 세워진 자동차, 등록된 자동차) |
| 참조변수(Reference Variable) | 객체의 주소(참조값)를 저장하는 변수 | 자동차 키(자동차를 가리키는 수단) |
| 메서드(method) | 객체가 수행할 수 있는 동작(함수) | 자동차의 기능(운전, 브레이크 등) |

> [!WARNING]
> 참조되지 않은 인스턴스 <br>
> 참조되지 않은 인스턴스는 쓰레기(Garbage)가 되며, 나중에 가비지 컬렉션(Garbage Collection)에 의해 메모리에서 제거됨.

<br>

### 클래스 선언 규칙

- **추상화**는 복잡한 현실 세계의 사물이나 개념에서 불필요한 세부사항을 제거하고, <br>  
  `핵심적인 특징`만을 뽑아내어 `하나의 클래스`로 표현할 때 사용.
    - ex) 자동차class => `엔진`, `바퀴`, `운전` 등  **공통적이고 중요한 특징**만 정의

#### 명명 규칙
* 클래스명은 대문자로 시작 `public class Pen()` | 파스칼표기법
* 예약어 금지
* 대소문자 구분
* `'_'` or `'$'` 는 허용

<br>

### 클래스 사용

```java
// pre code ..
public class Pen {
    // 필드
    int cnt;

    // 생성자  (= 없으면 컴파일에서 알아서 빈 생성자 제공)
    // public Pen() {
    //     System.out.println("Pen() 생성자 실행");
    // }

    // 메서드
    public void write(String msg) {
        System.out.println("펜쓰기 = " + msg);
    }
}
// next code ..

public class PenTest {
    public static void main(String[] args) {
        // 그냥 생성 호출
        new Pen();

        // 인스턴스 생성
        Pen ballPan = new Pen();

        // 해당 메서드 사용
        ballPan.write("안녕하세요!!");
    }
}
```
<br>

---

## 4. 필드 (Field)

* 클래스가 가지는 `속성`을 자바에선 `필드`라고 명칭.
* 다른언어에선 `멤버변수`라고 함.
* 객체의 `상태 정보`를 저장하는 역할.

```bash
# 필드(변수) 정의 형식
[접근제한자] [타입](int,String..) 필드명 = [초기값];
```
```java
// other package
public class User {
    // 인스턴스 필드
    String id;
    String name;
    String address = "서울시";

    // 클래스 필드 (static)
    static int age = 0;

    // 상수 (static final)
    static final int MAX_AGE = 150;


    // 접근제한
    public String nickName;     // 전체공개 - 어디서나 접근 가능
    private String rrn;         // 비공개 - 클래스 내부에서만 접근 가능
    String phone;               // (default) 같은 패키지에서만 접근 가능
    protected String email;     // 같은 패키지 또는 자식 클래스에서 접근 가능
}
```
```java
import common.User;

public class UserAdd extends User { // extends User : 익스텐드(상속) 
    public static void Main(String[] args) {
        User user01 = new User();

        // public: 어디서나 접근 가능
        user01.nickName = "홍길동";

        // default: 다른 패키지에서는 접근 불가 (X)
        // user01.phone = "010-1234-5678";

        // protected: 다른 패키지지만 extends로 상속해서 사용가능 (O) - 원래 불가 (X)
        user01.email = "hong@example.com";

        // private: 직접 접근 불가 (X)
        // user01.rrn = "900101-1234567";

        // static: 클래스명으로 어디서나 접근 가능 (O)
        User.age = 25;

        // static final: 값 변경 불가 (X) (상수)
        // User.MAX_AGE = 200;
    }
}
```
<br>

* **public** : 어디서나 접근 가능 
    - 모든 패키지, 모든 클래스에서 사용 가능

* **protected** : 같은 패키지 또는 상속받은 자식 클래스에서만 접근 가능
    - 다른패키지일 때 임포트 후 `extends 해당클래스명` 하면 상속됨.

* **default** : 접근제한자를 명시하지 않으면 default(패키지 전용) 
    - 같은 패키지에서만 접근 가능

* **private** : 클래스 내부에서만 접근 가능 
    - 외부에서는 직접 접근 불가 (getter,setter 아닌 이상)

<br>

> [!TIP]
> static 필드는 **클래스(설계도)당 하나만** 생성되며, 모든 인스턴스가 **공유**함. <br>
> 즉, 객체(인스턴스)가 여러 개 만들어져도 static 필드는 메모리에 하나만 할당되고, <br>
> 모든 객체가 그 값을 함께 사용함.


---
## 5. 메소드(Method)

> 하나의 객체는 메시지를 전송함으로써 다른 객체에 접근한다. 객체의 행동을 유발하는 `행위`를 가리켜 `메시지-전송`이라고 한다. <br> 
> `메시지-전송 메커니즘`은 객체가 `다른 객체에 접근할 수 있는 유일한 방법`이다.

```bash
# 메서드 정의 형식
[접근제한자] [static] 반환타입 메소드명(매개변수) {
    // 메소드 본문
    return 반환값;  // 반환타입이 void가 아닌 경우
}
```

<br>

### 예시
```java
// other package
public class Calc {
    public int optionKey(int a, int b, String key) {
        return (int)calcCore(a, b, key);
    }

    public double optionKey(double a, double b, String key) {
        return calcCore(a, b, key);
    }

    private double calcCore(double a, double b, String key) {
        switch (key) {
            case "+": return a + b;
            case "-": return a - b;
            case "%": return a % b;
            case "*": return a * b;
            case "/": return a / b;
            default:  return 0;
        }
    }
    
    public int addAll(int... numbers) {
        int total = 0;
        for(int num : numbers) {
            total += num;
        }
        return total;
    }
}
```
```java
public class CalcTest {
    public static void main(String[] args) {

        Calc calc = new Calc();

        int[] arr = {4, 5, 6};
        int sum0 = calc.addAll(arr);
        int sum1 = calc.addAll(1,2,3);
        double keyCalc = calc.optionKey((double)10, 3, "/");

        System.out.println("[4,5,6] calc.add(arr) : " + sum0);
        System.out.println("calc.add(1,2,3) : " + sum1);
        System.out.println("10 / 3 = " + keyCalc);

    }
}
```

```bash
# 실행결과
[4,5,6] calc.add(arr) : 15
calc.add(1,2,3) : 6
10 / 3 = 3.3333333333333335
```

---

## etc. 팀 회고에서 나온 내용

1. 가변 파라매터 `(int... params)` 사용시 해당 위치는 항상 `맨 뒤`여야함.
    - 다른 파라매터 있으면 먼저 선언후 마지막 가변 파라매터 사용
```java
// pre code...
public static void printData(String name, int... params) {
    int total = 0;
    for(int num : params) {
        total += num;
    }
    System.out.printf("학생: %s, 합계: %d%n", name, total);
}
// next code...
public static void main(String[] args) {
    int[] stuArr = {90, 80, 50};
    String stuName = "홍길동";
    printData(stuName, stuArr);
}
// next code...
```
```bash
# 실행 결과
학생: 홍길동, 합계: 220
```

<br>

2. 인텔리제이 자동완선 축약어 (작성후 `tab`)
   * `psvm` or `main` : 메인 메서드 만듬.
   * `sout` : System.out.println
   * `iter` : 향상된 for문
   * `itar` : for문
   * `ifn`  : `if(변수 == null)` 조건문
   * `inn`  : `if(변수 != null)` 조건문

<br>

3. 클래스 내 필드영역 선언시 다음 라인에서 값설정 불가함!
```java
class Person {
    String name;
    private String id;
    // 불가함!
    // name = "홍길동";
}

```