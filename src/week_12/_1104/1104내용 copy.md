# [ 12주차 - 1104 ] 스터디 내용

```bash
    금일 커리큘럼
        ├ 09:00 ~ 12:00 backend 프로그래밍 (Spring Boot의 스레드 모델, filter와 ThreadLocal)
        └ 13:00 ~ 18:00 backend 프로그래밍 (Spring Security, Spring Security 설정 방법, Spring Security 아키텍처)
```

## 1. Spring Boot의 스레드 모델

> Spring Boot 스레드 모델은 주로 서블릿 컨테이너의 스레드 모델을 따름

- 기본적으로 내장된 서블릿 컨테이너(Tomcat, Jetty, Undertow)를 사용하여 요청을 처리
- 하나의 요청을 하나의 스레드가 처리하는 구조

### Spring Boot 스레드 모델 특징

- 요청이 들어오면 서블릿 컨테이너가 스레드풀에서 스레드를 할당함
- 비동기 요청 처리를 지원하며, 별도의 비동기 작업 스레드 풀을 사용
- 각 요청은 독립적인 스레드에서 처리되어 동시성 문제를 최소화


### 스레드 설정 (tomcat 기준)

> tomcat은 기본적으로 최대 200개의 스레드, 최소 10개의 여유 스레드를 가짐

* **스레드 수 관련 옵션**
    - maxThreads: 최대 스레드 수
    - minSpareThreads: 최소 여유 스레드 수
    - acceptCount: 최대 대기 요청 수

#### 설정 예시

* **application.properties**

```properties
server.tomcat.max-threads=200
server.tomcat.min-spare-threads=10
server.tomcat.accept-count=100
```

* **application.yml**

```yaml
server:
  tomcat:
    max-threads: 200
    min-spare-threads: 10
    accept-count: 100
```

---

## 2. filter와 ThreadLocal 이해

### Filter란?

- 서블릿 요청과 응답을 가로채서 처리하는 컴포넌트
- 주로 인증, 로깅, 인코딩 처리 등에 사용
- 서블릿 컨테이너에서 제공하는 필터 체인에 등록되어 동작

```java
public class SimpleFilter implements Filter {
    @Override
    public void doFilter(
        ServletRequest request,
        ServletResponse response,
        FilterChain chain
    ) throws IOException, ServletException {
        chain.doFilter(request, response); // 다음 필터 또는 서블릿으로 요청 전달
    }
    // 기타 init, destroy 메서드 오버라이드 등..
}
```

### ThreadLocal이란?

- 각 스레드마다 독립적인 변수를 저장할 수 있는 공간을 제공하는 클래스
- 스레드 간에 데이터를 공유하지 않고, 스레드 로컬 변수를 통해 데이터 격리를 구현
- 주로 요청 처리 중에 사용자 정보나 트랜잭션 정보를 저장하는 데 사용


```java
public class ThreadLocalExample {
    // 각 스레드마다 독립적으로 값을 저장
    private static final ThreadLocal<String> threadLocal = new ThreadLocal<>();

    public static void main(String[] args) {
        threadLocal.set("스레드별 값");
        System.out.println(threadLocal.get()); // 현재 스레드의 값 출력
        threadLocal.remove(); // 값 삭제
    }
}
```


### Filter와 ThreadLocal의 관계

- **Filter**에서 **ThreadLocal**을 사용하여 요청 처리 중에 스레드 로컬 데이터를 저장하고 관리할 수 있음
- **인증 정보를 ThreadLocal에 저장**하여 요청 처리 중에 쉽게 접근 가능하며, <br> **다른 계층에서도 해당 스레드에 접근 가능**

### 예시

```
sequenceDiagram
    participant filter 1
    participant filter 2
    participant controller
    participant service
    participant ThreadLocal

    filter 1->>ThreadLocal: data 저장
    ThreadLocal->>filter 2: data 읽기
    ThreadLocal->>controller: data 읽기
    ThreadLocal->>service: data 읽기
```


### Filter에서 ThreadLocal 사용 예제

```java
// ThreadLocal 컨텍스트 설정 ------------------------
public class UserContext {
    private static final ThreadLocal<User> userThreadLocal = new ThreadLocal<>();

    public static void setUser(User user) {
        userThreadLocal.set(user);
    }

    public static User getUser() {
        return userThreadLocal.get();
    }

    public static void clear() {
        // 요청이 끝난 후 해당 스레드풀 남아있는 상태에서 재사용되기 때문에 삭제필요
        userThreadLocal.remove();
    }
}

// user 정보 필터 ------------------------
@WebFilter(urlPatterns = "/hello") // 특정 URL 패턴에 필터 적용
public class UserFilter implements Filter {
    @Override
    public void doFilter(
            ServletRequest request,
            ServletResponse response,
            FilterChain chain
    ) throws IOException, ServletException {
        System.out.println("[UserFilter] doFilter - start");

        try {
            String name = request.getParameter("name"); // 요청 파라미터에서 name 추출 (임시확인)
            UserContext.setUser(new User(name, 11));

            chain.doFilter(request, response);
            System.out.println("[UserFilter] doFilter - end");
            System.out.println(Thread.currentThread().getName());
        } finally {
            UserContext.clear(); // 필수!
        }
    }
    // 기타 init, destroy 메서드 오버라이드 등..
}
// 컨트롤러 ------------------------
@RestController
@Slf4j
public class UserController {
    private final UserService userService = new UserService();
    @GetMapping(value = {"/hello"})
    public String hello(){
        log.info("hello() 실행 !");
        userService.helloService();
        return "hello World";
    }
}
// 서비스 ------------------------
@Service
public class UserService {
    public void helloService() {
        System.out.println("[UserService] helloService() 실행");
        System.out.println(Thread.currentThread().getName());
        System.out.println(UserContext.getUser().getName());
    }
}
```

```bash
# 실행결과 "http://localhost:8080/hello?name=hong"
[UserFilter] init
[UserFilter] doFilter - start
00:00:00 [http-nio-8080-exec-2] INFO  packageSrc.UserController - hello() 실행 !
[UserService] helloService() 실행
http-nio-8080-exec-2    # 스레드 이름
kang                    # ThreadLocal에 저장된 name 값
[UserFilter] doFilter - end
http-nio-8080-exec-2    # 스레드 이름
```

### 주의사항

- ThreadLocal에 저장된 데이터는 요청이 끝난 후 반드시 삭제해야 함
- 스레드풀 환경에서 스레드가 재사용될 때 이전 요청의 데이터가 남아 있을 수 있음
- 메모리 누수 문제를 방지하기 위해 clear() 메서드를 호출하여 ThreadLocal 데이터를 제거해야 함


---


## 3. Spring Security

> Spring Security는 스프링 기반 애플리케이션에 보안 기능을 제공하는 프레임워크

- 인증(Authentication)과 권한 부여(Authorization)를 처리
- 다양한 보안 요구사항을 충족시키기 위한 기능 제공
- 주로 모듈화, 확장성, 그리고 선언적 보안 설정에 기반을 둠

### Spring Security의 주요 기능

1. **인증(Authentication)**
    - 사용자 신원 확인하는 과정
    - 다양한 인증 메커니즘 지원 (폼 로그인, HTTP Basic, OAuth2, JWT 등)

2. **권한 부여(Authorization)**
    - 인증된 사용자가 특정 자원에 접근할 수 있는지 결정
    - 역할 기반 접근제어 (RBAC)를 포함한 다양한 접근 제어방 식 지원

3. **세션관리**
    - 사용자의 세션의 생성, 유지, 만료 등을 관리하여 보안성 높임

4. **보안 이벤트 로깅**
    - 로그인 시도, 실패 등 보안 관련 이벤트를 로깅하여 감사 추적 가능


---

## 4. Spring Security 설정 방법

### build.gradle 의존성 추가

```gradle
dependencies {
    implementation 'org.springframework.boot:spring-boot-starter-security'
    implementation 'org.springframework.boot:spring-boot-starter-web'
}
```

### 시큐리티 계정 설정

* 기본은 user / 랜덤 비밀번호 (server run 시 log에 출력됨)

1. **application.properties 설정 방법**

```bash
spring.security.user.name=admin123     # 시큐리티 사용자명 설정
spring.security.user.password=admin123 # 시큐리티 비밀번호 설정
spring.security.user.roles=ADMIN       # 시큐리티 권한 설정
```

2. **application.yml 설정 방법**

```yml
spring:
  security:
    user:
      name: admin123      # 시큐리티 사용자명 설정
      password: admin123  # 시큐리티 비밀번호 설정
      roles: ADMIN        # 시큐리티 권한 설정
```

### security config 사용 예시

1. **시큐리티 기본 설정 방법**

```java
@Configuration
@EnableWebSecurity
public class SecurityConfig {
    @Bean
    public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {

        // 1. 기본 Spring Security 설정
        return http
                //  HTTP 요청에 대한 접근 권한을 설정
                .authorizeHttpRequests(auth -> auth
                    .anyRequest() // 모든요청
                    .authenticated() // 인증요구
                )
                .formLogin(Customizer.withDefaults()) // 기본 로그인 폼 사용
                .httpBasic(Customizer.withDefaults()) // HTTP Basic 인증 지원
                .csrf(Customizer.withDefaults()) // CSRF 보호 활성화
                .build();

    }
}
```

2. **커스텀 URL 접근 권한 설정 방법**

```java
@Configuration
@EnableWebSecurity
public class SecurityConfig {
    @Bean
    public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {
        // 2. 특정 경로는 인증 없이 허용하는 설정
        return http
                .authorizeHttpRequests(auth -> auth
                        .requestMatchers("/", "/home", "/public/**").permitAll() // 인증 없이 허용
                        .requestMatchers("/admin/**").hasRole("ADMIN") // ADMIN 권한 필요
                        .anyRequest().authenticated() // 나머지는 인증 필요
                )
                .formLogin(Customizer.withDefaults())
                .build();
    }
}
```

3. **커스텀 로그인 폼 설정 방법**

```java
@Configuration
@EnableWebSecurity
public class SecurityConfig {
    @Bean
    public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {
        // 3. 커스텀 로그인 폼 설정
        return http
                .authorizeHttpRequests(auth -> auth
                        .requestMatchers("/loginForm", "/").permitAll()
                        .anyRequest().authenticated()
                )
                .formLogin(form -> form
                        // 개발자가 작업한 로그인폼 화면 사용 (없으면 시큐리티 폼로그인 사용됨)
                        // .loginPage("/loginForm")
                        .loginProcessingUrl("/login_proc") // form의 action 경로 설정
                        .usernameParameter("email") // 사용자명 input name 지정 (기본 값: username)
                        .passwordParameter("password") // 비밀번호 input name 지정 (기본 값: password)
                        // 로그인 성공시 이동할 페이지 (true: 무조건 이동, false: 이전 페이지로 이동)
                        .defaultSuccessUrl("/dashboard", true)
                        .failureUrl("/fail") // 로그인 실패시 이동할 페이지
                )
                .build();
    }
}
```

4. **로그인/로그아웃 핸들러 추가 방법**

```java
@Configuration
@EnableWebSecurity
public class SecurityConfig {
    @Bean
    public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {
        // 4. 로그인/로그아웃 처리 핸들러 추가
        return http
                .authorizeHttpRequests(auth -> auth
                        .requestMatchers("/loginForm", "/").permitAll()
                        .anyRequest().authenticated()
                )
                .formLogin(form -> form
                        .loginPage("/loginForm")
                        // 로그인 성공 핸들러
                        .successHandler((request, response, authentication) -> {
                            System.out.println("로그인 성공: " + authentication.getName());
                            response.sendRedirect("/dashboard");
                        })
                        // 로그인 실패 핸들러
                        .failureHandler((request, response, exception) -> {
                            System.out.println("로그인 실패: " + exception.getMessage());
                            response.sendRedirect("/fail");
                        })
                )
                .logout(logout -> logout
                        // 로그아웃 처리 URL (없으면 시큐리티 기본 /logout 사용)
                        // .logoutUrl("/logout_process") // POST 전용 - GET방식은 보안 취약
                        .logoutSuccessUrl("/") // 로그아웃 성공 후 이동할 페이지
                        .addLogoutHandler((request, response, authentication) -> {
                            System.out.println("로그아웃 처리: 세션 및 쿠키 삭제");
                        })
                        .deleteCookies("JSESSIONID") // 쿠키 삭제
                )
                .build();
    }
}
```

---

## 5. Spring Security 아키텍처

> Spring Security는 **필터 체인(Filter Chain)** 기반의 아키텍처를 사용함


### 5.1. 전체 아키텍처 흐름도

```mermaid
graph TD
    A[Client Request] --> B[DelegatingFilterProxy]
    B --> C[FilterChainProxy]
    C --> D{SecurityFilterChain 선택}
    D --> E[Security Filters 체인]
    E --> F[SecurityContextPersistenceFilter]
    F --> G[AuthenticationFilter]
    G --> H[AuthorizationFilter]
    H --> I[Controller/Service]
    I --> J[Response]
    
    K[AuthenticationManager] --> L[AuthenticationProvider]
    L --> M[UserDetailsService]
    L --> N[PasswordEncoder]
    
    G --> K
```

### 5.2. 실제 동작 과정

1. **요청 수신**: 클라이언트 요청이 서블릿 컨테이너로 들어옴
2. **DelegatingFilterProxy**: 서블릿 필터가 Spring의 FilterChainProxy로 위임
3. **FilterChainProxy**: 요청 URL에 맞는 SecurityFilterChain 선택
4. **Security Filters 실행**: 선택된 체인의 필터들이 순차적으로 실행
5. **인증/인가 처리**: 각 필터가 인증과 권한 검사 수행
6. **SecurityContext 관리**: ThreadLocal을 통해 인증 정보 저장/관리
7. **컨트롤러 처리**: 모든 보안 검사를 통과하면 실제 비즈니스 로직 실행


### 5.3 핵심 아키텍처 구성 요소

#### DelegatingFilterProxy

- 서블릿 컨테이너와 Spring ApplicationContext를 연결하는 다리 역할
- 서블릿 필터로 등록되어 모든 요청을 Spring Security로 위임
- Spring Bean으로 등록된 FilterChainProxy에게 실제 처리를 위임

```java
// 서블릿 필터 체인 → DelegatingFilterProxy → Spring Security 필터 체인
DelegatingFilterProxy → FilterChainProxy → SecurityFilterChain
```

#### FilterChainProxy

- Spring Security의 핵심 필터
- 여러 개의 SecurityFilterChain을 관리하고 적절한 체인을 선택
- 요청 URL 패턴에 따라 다른 보안 정책 적용 가능

```java
@Component
public class FilterChainProxy extends GenericFilterBean {
    private List<SecurityFilterChain> filterChains;
    
    @Override
    public void doFilter(
        ServletRequest request, 
        ServletResponse response, 
        FilterChain chain
        ) throws IOException, ServletException {
        // 요청에 맞는 SecurityFilterChain 선택하여 처리
    }
}
```

#### SecurityFilterChain

- 특정 요청 패턴에 대한 보안 필터들의 체인
- URL 패턴별로 다른 보안 정책을 적용할 수 있도록 함
- 여러 개의 SecurityFilterChain을 등록하여 다양한 보안 요구사항 처리

```java
@Configuration
@EnableWebSecurity
public class SecurityConfig {
    
    // API 요청용 SecurityFilterChain
    @Bean
    @Order(1)
    public SecurityFilterChain apiFilterChain(HttpSecurity http) throws Exception {
        return http
            .requestMatchers("/api/**")
            .authorizeHttpRequests(auth -> auth.anyRequest().authenticated())
            .oauth2ResourceServer(oauth2 -> oauth2.jwt())
            .build();
    }
    
    // 일반 웹 요청용 SecurityFilterChain
    @Bean
    @Order(2)
    public SecurityFilterChain webFilterChain(HttpSecurity http) throws Exception {
        return http
            .authorizeHttpRequests(auth -> auth
                .requestMatchers("/public/**").permitAll()
                .anyRequest().authenticated()
            )
            .formLogin(Customizer.withDefaults())
            .build();
    }
}
```

### 5.4. Security Filters (보안 필터들)

Spring Security는 다양한 보안 필터들을 제공됨

```bash
# 핵심 Security Filters 실행 순서
1. SecurityContextPersistenceFilter    # SecurityContext 로드/저장
2. CorsFilter                         # CORS 처리
3. CsrfFilter                         # CSRF 보안
4. LogoutFilter                       # 로그아웃 처리
5. UsernamePasswordAuthenticationFilter  # 폼 로그인
6. BasicAuthenticationFilter          # HTTP Basic 인증
7. BearerTokenAuthenticationFilter    # JWT/Bearer 토큰
8. AnonymousAuthenticationFilter      # 익명 사용자 처리
9. SessionManagementFilter            # 세션 관리
10. ExceptionTranslationFilter        # 예외 처리
11. AuthorizationFilter               # 권한 검사 (마지막)

# 필터는 총 30개지만, 핵심은 위와 같이 11개
```

#### 주요 필터들 상세 설명

**1. SecurityContextPersistenceFilter**

* SecurityContext를 HttpSession에서 로드하고 저장하는 필터

```java
// SecurityContext를 HttpSession에서 로드하고 저장
public class SecurityContextPersistenceFilter extends GenericFilterBean {
    @Override
    public void doFilter(
        ServletRequest request, 
        ServletResponse response, 
        FilterChain chain
    ) throws IOException, ServletException {
        // 세션에서 SecurityContext 로드
        SecurityContext contextBeforeChainExecution = loadContext(request);
        SecurityContextHolder.setContext(contextBeforeChainExecution);
        
        try {
            chain.doFilter(request, response);
        } finally {
            // 변경된 SecurityContext를 세션에 저장
            saveContext(contextBeforeChainExecution, request, response);
            SecurityContextHolder.clearContext();
        }
    }
}
```

**2. UsernamePasswordAuthenticationFilter**

* 폼 로그인 처리 필터

```java
// 폼 로그인 처리
public class UsernamePasswordAuthenticationFilter extends AbstractAuthenticationProcessingFilter {
    @Override
    public Authentication attemptAuthentication(
        HttpServletRequest request, 
        HttpServletResponse response
    ) throws AuthenticationException {
        String username = obtainUsername(request);
        String password = obtainPassword(request);
        
        UsernamePasswordAuthenticationToken authRequest = 
            new UsernamePasswordAuthenticationToken(username, password);
        
        return this.getAuthenticationManager().authenticate(authRequest);
    }
}
```

**3. BasicAuthenticationFilter**

* HTTP Basic 인증 처리 필터

```java
// HTTP Basic 인증 처리
public class BasicAuthenticationFilter extends OncePerRequestFilter {
    @Override
    protected void doFilterInternal(
        HttpServletRequest request, 
        HttpServletResponse response, 
        FilterChain chain
    ) throws IOException, ServletException {
        String header = request.getHeader("Authorization");
        if (header != null && header.startsWith("Basic ")) {
            // Base64 디코딩하여 username:password 추출
            // 인증 처리 수행
        }
        chain.doFilter(request, response);
    }
}
```

**4. AuthorizationFilter**

* 권한 검사 수행 필터

```java
// 권한 검사 수행 (마지막 필터)
public class AuthorizationFilter extends OncePerRequestFilter {
    @Override
    protected void doFilterInternal(
            HttpServletRequest request, 
            HttpServletResponse response, 
            FilterChain chain
        ) throws IOException, ServletException {
        // 현재 요청에 대한 권한 검사
        AuthorizationDecision decision = authorizationManager.check(authentication, request);
        
        if (decision != null && !decision.isGranted()) {
            throw new AccessDeniedException("Access Denied");
        }
        
        chain.doFilter(request, response);
    }
}
```

---

