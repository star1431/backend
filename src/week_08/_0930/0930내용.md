# [ 8주차 - 0930 ] 스터디 내용

```bash
    금일 커리큘럼
        ├ 09:00 ~ 14:00 백엔드 프로그래밍 (Stream API, 스트림 사용과 생성)
        └ 14:00 ~ 18:00 백엔드 프로그래밍 (스트림과 객체 참조, 스트림 연산 활용, 옵셔널 클래스)
```

## 1. Stream API

> **Interface Stream<T>** - java8 부터 추가된 기능 


### 스트림이란?

* 데이터의 흐름을 추상화한 것
* 컬렉션(배열, 리스트 등)의 요소들을 하나씩 처리하는데 사용
* 병렬 처리에 용이
* 함수형 프로그래밍을 지원
    - 람다식과 함께 사용됨


### 스트림 특징

* **원본 유지** : 스트림 연산은 원본 데이터를 변경하지 않음 
* **재사용 불가** : 한번 사용 후 종료됨
* **내부 반복** : `foreach`로 간결하게 표현 가능
* **지연 연산** : 최종 연산이 호출될 때까지 연산


### 스트림과 컬렉션의 차이점

* 컬렉션은 데이터의 저장과 관리를 위한 자료구조
* 스트림은 컬렉션의 요소들을 처리하는데 사용되는 추상화된 개념임

| 구분 | 컬렉션 | 스트림 |
|---|---|---|
| **데이터 저장** | 모든 데이터를 메모리에 저장 | 필요한 데이터만 처리 |
| **데이터 처리** | 명시적 반복 | 내부 반복 |
| **데이터 계산** | 즉시 | 지연 |
| **재사용** | O | X |
| **병렬처리** | 직접구현 | parallelStream() |

---

## 2. 스트림 사용과 생성

* 스트림은 메서드를 통해 사용하거나 스트림 객체를 생성하여 사용할 수 있음.
* 단, 스트림 객체 한번 사용 후 재사용 불가함.
    - IllegalStateException 발생

### 메서드 사용 및 컬렉션 스트림 생성 예시

* 스트림 관련 메서드 : filter(), map(), forEach(), collect() 등...
* 컬렉션의 stream() 메서드로 스트림 생성 가능

```java
public class StreamCreationExam {
    public static void main(String[] args) {
        // 1. 메서드 사용
        List<String> lists = Arrays.asList("Java", "Python", "C++", "JavaScript", "SQL");
        lists.stream()
                .filter(item -> item.toLowerCase().startsWith("j"))
                .forEach(System.out::println);
                //  Java \n JavaScript

        // 스트림은 원본배열 변경하지 않음
        System.out.println(lists); 

        // 2. 컬렉션 스트림 생성
        Stream<String> stream = lists.stream();
        stream.forEach(item -> System.out.print(item + " "));
        System.out.println();

        // 재사용불가함
        try {
            stream.forEach(System.out::println);
        } catch (IllegalStateException e) {
            System.out.println(e.getMessage());
            // stream has already been operated upon or closed
        }
    }
}
```



### 배열 스트림 생성

* Arrays.stream() 메서드 사용
* 배열의 일부로부터 스트림 생성 가능

```java
String[] strArr = {"내용1", "내용2", "내용3"};
// 배열로부터 스트림 생성
Stream<String> streamFromArray = Arrays.stream(strArr);
// 배열의 일부로부터 스트림 생성 (인덱스 1부터 3까지)
Stream<String> partialStream = Arrays.stream(strArr, 1, 3);
```

### 스트림 정적 메서드

* Stream.of(), Stream.empty(), Stream.generate() 등
* 다양한 방식으로 스트림 생성 가능

```java
// 1. Stream.of() - 주어진 값들로부터 스트림 생성
Stream<String> streamOf = Stream.of("A", "B", "C");

// 2. Stream.empty() - 빈 스트림 생성
Stream<String> emptyStream = Stream.empty();

// 3. Stream.generate() - 무한 스트림 생성
Stream<Double> randomNumbers = Stream.generate(Math::random).limit(5);
```

---


## 2. 스트림과 객체 참조

* 스트림으로 수집된 컬렉션은 **항상 얕은 복사**
* 차이는 **가변/불변 객체**에 따른 **영향의 가시성**

### 가변객체와 불변객체

- **가변객체**: 객체 내부 상태 변경 가능 (StringBuilder, 배열, 사용자 정의 클래스 등)
- **불변객체**: 객체 내부 상태 변경 불가 (String, Integer, Double 등)

### 얕은 복사 - 가변 객체 (영향 o)

```java
// StringBuilder - 가변 객체
List<StringBuilder> original = new ArrayList<>();
original.add(new StringBuilder("Java"));
original.add(new StringBuilder("JavaScript"));

List<StringBuilder> collected = original.stream()
        .filter(sb -> sb.toString().toLowerCase().startsWith("j"))
        .collect(Collectors.toList());

// 원본 객체 수정 - 수집된 컬렉션에도 영향!
original.get(0).append(" 21");

System.out.println(original);  // [Java 21, JavaScript]
System.out.println(collected); // [Java 21, JavaScript] <- 얕은복사

// ------------------------------------------------

// 배열 - 가변 객체
List<String[]> originalArr = new ArrayList<>();
originalArr.add(new String[]{"Java", "Python"});

List<String[]> collectedArr = originalArr.stream()
        .filter(arr -> arr[0].toLowerCase().startsWith("j"))
        .collect(Collectors.toList());

// 원본 배열 수정 - 수집된 컬렉션에도 영향
originalArr.get(0)[0] = "Java 21";

System.out.println(Arrays.toString(originalArr.get(0)));  // [Java 21, Python]
System.out.println(Arrays.toString(collectedArr.get(0))); // [Java 21, Python] <- 얕은복사
```

### 얕은 복사 - 불변 객체 (영향 x)

* 불변객체인 경우 얕은복사의 영향은 안보이지만 깊은 복사는 아님

```java
// String - 불변 객체
List<String> original = new ArrayList<>(Arrays.asList("Java", "Js", "Python"));

List<String> collected = original.stream()
        .filter(item -> item.toLowerCase().startsWith("j"))
        .collect(Collectors.toList());

// 리스트 요소 교체 (새로운 String 객체로)
original.set(1, "JavaScript");

System.out.println(original);  // [Java, JavaScript, Python]
System.out.println(collected); // [Java, Js] ← 영향 없음 (String 불변)

```

### 진짜 깊은 복사 (가변 객체)

```java
// StringBuilder 깊은 복사 - 새로운 객체 생성
List<StringBuilder> original = new ArrayList<>();
original.add(new StringBuilder("Java"));
original.add(new StringBuilder("JavaScript"));

// map으로 새로운 StringBuilder 객체 생성 - 깊은 복사!
List<StringBuilder> deepCopy = original.stream()
        .filter(sb -> sb.toString().toLowerCase().startsWith("j"))
        .map(sb -> new StringBuilder(sb.toString()))  // 새 객체 생성!
        .collect(Collectors.toList());

// 원본 수정
original.get(0).append(" 21");

System.out.println(original); // [Java 21, JavaScript]
System.out.println(deepCopy); // [Java, JavaScript] ← 깊은복사
```

> **그냥 toList() 와 Collectors.toList() 의 차이**

* `Stream.collect(Collectors.toList())`: 가변 리스트 반환
* `Stream.toList()`: 불변 리스트 반환 (고정크기)

```java
List<String> mutableList = stream.collect(Collectors.toList());
mutableList.add("New Item"); // 가능

List<String> immutableList = stream.toList();
// immutableList.add("New Item"); // 익셉션오류
```

---

## 3. 스트림 연산 활용


### 3.1 데이터 필터링과 변환

* **filter()** : 조건에 맞는 요소만 추출
* **map()** : 요소를 다른 형태로 변환
* **distinct()** : 중복 요소 제거
* **flatMap()** : 중첩된 구조를 평탄화 (1차원으로 변환)

```java
List<String> words = Arrays.asList(
    "Apple", "Banana", "Orange", "Apple", "Grape", "Mango", "Banana"
);
List<String> result = 
    words.stream()
        .filter(item -> item.length() >= 5) // 길이 5 이상 필터링
        .map(String::toUpperCase)            // 대문자로 변환
        .distinct()                          // 중복제거
        .collect(Collectors.toList());       // 리스트로 수집

System.out.println(result); // [APPLE, BANANA, ORANGE, GRAPE, MANGO]

// flatMap 예시
List<List<String>> nestedList = Arrays.asList(
    Arrays.asList("A", "B"),
    Arrays.asList("C", "D"),
    Arrays.asList("E", "F")
);
List<String> flatList = 
    nestedList.stream()
        .flatMap(List::stream)               // 중첩된 리스트 평탄화
        .collect(Collectors.toList());

System.out.println(flatList); // [A, B, C, D, E, F]
```

### 3.2 데이터 정렬과 순회

* **sorted()** : 요소를 정렬 (기본 오름차순)
    - 값 **Comparator.reverseOrder()** 으로 내림차순 가능
    - **int 배열** 내림차순 경우 **boxed()** 필요
* **forEach()** : 요소를 하나씩 순회하며 처리
* **peek()** : 중간 연산에서 요소를 확인 (디버깅용)

```java
List<Integer> numbers = Arrays.asList(5, 3, 8, 1, 2, 7);

// 오름차순 정렬
numbers.stream()
        .sorted()   // 기본 오름차순 정렬
        .forEach(item -> System.out.print(item + " "));
System.out.println();
// 1 2 3 5 7 8

// 내림차순 정렬
numbers.stream()
        .sorted(Comparator.reverseOrder())  // 내림차순 정렬
        .forEach(item -> System.out.print(item + " "));
System.out.println();
// 8 7 5 3 2 1

// int 배열인 경우 내림차순 ★★★
int[] intNums = {5, 3, 8, 1, 2, 7};
Arrays.stream(intNums)
        .boxed() // int -> Integer 박싱
        .sorted(Comparator.reverseOrder())
        .forEach(item -> System.out.print(item + " "));


// peek() 예시
numbers.stream()
        .filter(item -> item % 2 == 0) // 짝수 필터링
        .peek(item -> System.out.print("짝수: " + item)) // 중간 확인
        .map(item -> item * item) // 제곱으로 변환
        .peek(item -> System.out.print(", 제곱: " + item + " | "))
        .forEach(item -> System.out.print(item + " "));
        // 짝수: 8, 제곱: 64 | 64 짝수: 2, 제곱: 4 | 4 
```

### 3.3 데이터 매칭과 검색


#### 데이터 매칭

* **allMatch()** : 모든 요소가 조건에 맞는지 확인
* **anyMatch()** : 조건에 맞는 요소가 하나라도 있는지 확인
* **noneMatch()** : 조건에 맞는 요소가 없는지 확인

```java
List<Integer> numbers = Arrays.asList(5, 3, 8, 1, 2, 7);

boolean allcheck = 
    numbers.stream()
        .allMatch(n -> n % 2 == 0);
System.out.println("전부 짝수?: " + allcheck); // false

boolean anycheck = 
    numbers.stream()
        .anyMatch(n -> n % 2 == 0);
System.out.println("하나라도 짝수?: " + anycheck); // true

boolean nonecheck = 
    numbers.stream()
        .noneMatch(n -> n < 0);
System.out.println("음수 없음?: " + nonecheck); // true

```

#### 데이터 검색

* **findFirst()** : 조건에 맞는 첫번째 요소 반환 (Optional)
* **findAny()** : 조건에 맞는 아무 요소나 반환 (병렬처리 시 사용)
    - parallelStream() 사용 시 성능 향상 가능

```java
List<Integer> numbers = Arrays.asList(5, 3, 8, 1, 2, 7);

// Optional - null 방지 (다른 섹션에서 설명)
Optional<Integer> first = 
    numbers.stream()
        .filter(n -> n % 2 == 0)
        .findFirst();

first.ifPresent(
        n -> System.out.println("첫번째 짝수: " + n)
    ); // 첫번째 짝수: 8

Optional<Integer> any = 
    numbers.parallelStream() // 병렬 스트림 성능 향상
        .filter(n -> n > 3)
        .findAny();

any.ifPresent(
        n -> System.out.println("3보다 큰 아무 값: " + n)
    ); // 3보다 큰 아무 값: 5 
```

### 3.4 집계 연산

* **count()** : 요소 개수 반환
* **min()** : 최소값 반환 (Optional)
* **max()** : 최대값 반환 (Optional)

```java
List<Integer> numbers = Arrays.asList(5, 3, 8, 1, 2, 7);

long count = 
    numbers.stream()
        .filter(n -> n % 2 == 0)
        .count();

System.out.println("짝수 개수: " + count); // 2

Optional<Integer> min = 
    numbers.stream()
        .min(Integer::compareTo);

min.ifPresent(
        n -> System.out.println("최소값: " + n)
    ); // 최소값: 1

Optional<Integer> max = 
    numbers.stream()
        .max(Integer::compareTo);

max.ifPresent(
        n -> System.out.println("최대값: " + n)
    ); // 최대값: 8
```


### 3.5 집계 연산

* **count()** : 요소 개수 반환
* **sum()** : 합계 반환
* **average()** : 평균 반환 (OptionalDouble)
* **summaryStatistics()** : 통계 정보 요약 (IntSummaryStatistics 등)

```java
List<Integer> numbers = Arrays.asList(1,2,3,4,5,6,7,8,9,10);

int count =
    (int) numbers.stream()
            .filter(item -> item > 5)
            .count();
System.out.println("5초과 개수: " + count); // 개수: 5

int sum = 
    numbers.stream()
        .mapToInt(Integer::intValue) // IntStream으로 변환
        .sum();

System.out.println("합계: " + sum); // 합계: 10

double avg = 
    numbers.stream()
        .mapToInt(Integer::intValue)
        .average()
        .orElse(0.0); // 값이 없을 때 기본값 지정

System.out.println("평균: " + avg); // 평균: 5.5

IntSummaryStatistics stats = 
    numbers.stream()
        .mapToInt(Integer::intValue)
        .summaryStatistics();

System.out.println(stats);
// IntSummaryStatistics{count=10, sum=55, min=1, average=5.500000, max=10}
System.out.println("최소값: "   + stats.getMin()); // 최소값: 1
System.out.println("최대값: "   + stats.getMax()); // 최대값: 10
System.out.println("합계: "     + stats.getSum()); // 합계: 55
System.out.println("평균: "     + stats.getAverage()); // 평균: 5.5
System.out.println("개수: "     + stats.getCount()); // 개수: 10


```

### 3.6 리듀싱 & 수집

#### reduce와 collect

* **reduce()** : 요소들을 하나로 합침 (누적 연산)
* **collect()** : 요소들을 컬렉션으로 수집 (Collectors 사용)

```java
List<Integer> numbers = Arrays.asList(1,2,3,4,5);

// reduce() - 합계 계산
int sum =
    numbers.stream()
        .reduce(0, (a, b) -> a + b); // 초기값 0
System.out.println("합계: " + sum); // 합계: 15

// collect() - 리스트로 수집
List<Integer> evenNumbers =
    numbers.stream()
        .filter(n -> n % 2 == 0)
        .collect(Collectors.toList());

System.out.println("짝수 리스트: " + evenNumbers); // 짝수 리스트: [2, 4]
```

#### Collectors 수집

* **toList()** : 리스트로 수집
* **toSet()** : 집합으로 수집 (중복제거)
* **toMap()** : 맵으로 수집 (키-값 쌍)
* **joining()** : 문자열로 결합

```java
import java.util.*;
import java.util.stream.Collectors;

class Person {
    private String name;
    private int age;

    public Person(String name, int age) {
        this.name = name;
        this.age = age;
    }

    public String getName() { return name; }
    public int getAge() { return age; }

    @Override
    public String toString() {
        return "Person{" +
                "name='" + name + '\'' +
                ", age=" + age +
                '}';
    }

    @Override
    public boolean equals(Object o) {
        if (o == null || getClass() != o.getClass()) return false;
        Person person = (Person) o;
        return age == person.age && Objects.equals(name, person.name);
    }

    @Override
    public int hashCode() {
        return Objects.hash(name, age);
    }
}

public class CollectorsExam {
    public static void main(String[] args) {
        List<Person> people = Arrays.asList(
                new Person("신짱구", 30),
                new Person("김철수", 25),
                new Person("이유리", 30),
                new Person("이유리", 30)
                );

        // toList() - 리스트로 수집
        List<Person> list =
            people.stream()
                .filter(p -> p.getAge() >= 30)
                .collect(Collectors.toList());
        System.out.println("[List] 30세 이상: " + list);

        // toSet() - 집합으로 수집 (중복제거)
        Set<Person> set =
            people.stream()
                .collect(Collectors.toSet());
        System.out.println("[Set] 전체(중복빠짐): " + set);

        // toMap() - 맵으로 수집 (키-값 쌍)
        Map<String, Person> map =
            people.stream()
                .collect(Collectors.toMap(
                    Person::getName, // 키: 이름
                    p -> p,         // 값: Person 객체
                    (before, after) -> before // (기존, 새로운) -> 기존 (중복키 처리방식)
                ));
        System.out.println("[Map] 이름-객체 쌍: " + map);

        // joining() - 문자열로 결합
        String names = 
            people.stream()
                .map(Person::getName)
                .collect(Collectors.joining(", ", "[", "]"));
        System.out.println("[Joining] 이름들: " + names);
    }
}
```

```bash
#출력결과
[List] 30세 이상: 
    [Person{name='신짱구', age=30}, 
    Person{name='이유리', age=30}, 
    Person{name='이유리', age=30}]

[Set] 전체(중복빠짐): 
    [Person{name='이유리', age=30}, 
    Person{name='신짱구', age=30}, 
    Person{name='김철수', age=25}]

[Map] 이름-객체 쌍: 
    {이유리=Person{name='이유리', age=30}, 
    김철수=Person{name='김철수', age=25}, 
    신짱구=Person{name='신짱구', age=30}}

[Joining] 이름들: [신짱구, 김철수, 이유리, 이유리]
```


### 3.7 그룹화

* **groupingBy()** : 요소들을 특정 기준으로 그룹화 (맵 형태)
* **partitioningBy()** : 요소들을 조건에 따라 두 그룹으로 분할 (맵 형태)

```java
import java.util.*;
import java.util.stream.Collectors;

class Product {
    private String name;
    private String category;
    private Long price;

    public Product(String name, String category, Long price) {
        this.name = name;
        this.category = category;
        this.price = price;
    }

    public String getName() { return name; }
    public String getCategory() { return category; }
    public Long getPrice() { return price; }

    @Override
    public String toString() {
        return "Product{" +
                "name='" + name + '\'' +
                ", category='" + category + '\'' +
                ", price=" + price +
                '}';
    }
}

public class GroupingExam {
    public static void main(String[] args) {
        List<Product> products = Arrays.asList(
            new Product("TV", "전자제품", 500_000),
            new Product("스마트폰", "전자제품", 1_000_000),
            new Product("노트북", "전자제품", 1_5000_000),
            new Product("의자", "가구", 150_000),
            new Product("책상", "가구", 300_000),
            new Product("볼펜", "문구", 800)
        );

        // groupingBy() - 카테고리별 그룹화
        Map<String, List<Product>> groupPing1 = 
            products.stream()
                .collect(Collectors.groupingBy(Product::getCategory));
        System.out.println("[groupingBy] 카테고리별 그룹화: " + groupPing1);

        // partitioningBy() - 가격 1백만원 이상/미만으로 분할
        Map<Boolean, List<Product>> groupPing2 = 
            products.stream()
                .collect(Collectors.partitioningBy(p -> p.getPrice() >= 1_000_000));
        System.out.println("[partitioningBy] 가격 1백만원 이상/미만 분할: " + groupPing2);

        // 카테고리별 평균 가격
        Map<String, Double> avgPriceByCategory =
            products.stream()
                    .collect(Collectors.groupingBy(
                        Product::getCategory,
                        Collectors.averagingLong(Product::getPrice)
                        // averagingLong, averagingInt -> long, int 타입 필드 평균
                        // averagingDouble -> double 타입 필드 평균
                        // 근데 반환은 전부 Double타입으로 반환됨
                    ));
        System.out.println("[averagingLong] 카테고리별 평균 가격: " + avgPriceByCategory);

    }
}
```

```bash
#출력결과
[groupingBy] 카테고리별 그룹화: 
{
    문구=[Product{name='볼펜', category='문구', price=800}], 
    전자제품=[
        Product{name='TV', category='전자제품', price=500000}, 
        Product{name='스마트폰', category='전자제품', price=1000000}, 
        Product{name='노트북', category='전자제품', price=1500000}
    ], 
    가구=[
        Product{name='의자', category='가구', price=150000}, 
        Product{name='책상', category='가구', price=300000}
    ]
}
[partitioningBy] 가격 1백만원 이상/미만 분할: 
{
    false=[
        Product{name='TV', category='전자제품', price=500000}, 
        Product{name='의자', category='가구', price=150000}, 
        Product{name='책상', category='가구', price=300000}, 
        Product{name='볼펜', category='문구', price=800}
    ], 
    true=[
        Product{name='스마트폰', category='전자제품', price=1000000}, 
        Product{name='노트북', category='전자제품', price=1500000}
    ]
}
[averagingLong] 카테고리별 평균 가격: {문구=800.0, 가구=225000.0, 전자제품=1000000.0}
```

### 3.8 스트림 병렬 처리

* **parallelStream()** : 컬렉션에서 병렬 스트림 생성

```java
List<Integer> numbers = new ArrayList<>();
for (int i = 1; i <= 1_000_000; i++) {
    numbers.add(i);
}

// 순차 스트림 처리 시간 측정
long startTime0 = System.currentTimeMillis();

numbers.stream()
    .mapToInt(Integer::intValue).sum();

long endTime0 = System.currentTimeMillis();


// 병렬 스트림 처리 시간 측정

startTime1 = System.currentTimeMillis();

numbers.parallelStream()
    .mapToInt(Integer::intValue).sum();

endTime1 = System.currentTimeMillis();

System.out.println("순차 스트림 처리 시간: " + (endTime0 - startTime0) + "ms");
System.out.println("병렬 스트림 처리 시간: " + (endTime1 - startTime1) + "ms");

```


---


## 4. 옵셔널 클래스

>  **Optional\<T> - null 방지용 래퍼 클래스**

* Optional.of(value) : null이 아닌 값으로 Optional 생성
* Optional.ofNullable(value) : null일 수도 있는 값으로 Optional 생성
* Optional.empty() : 빈 Optional 생성
* isPresent() : 값 존재 여부 확인
* ifPresent(func) : 값이 존재하면 func 실행
* ifPresentOrElse(func, Runnable) : 값이 존재하면 func 실행, 없으면 Runnable 실행
* orElse(other) : 값이 존재하면 반환, 없으면 other 반환
* orElseGet(func) : 값이 존재하면 반환, 없으면 func 실행 후 반환

### Optional 메서드 확인

```java
Optional<Integer> optTest = Optional.empty();

// Optional.ofNullable(값)
optTest = Optional.ofNullable(null); // null 가능

// Optional.of(값)
optTest = Optional.of(100); // null 불가

// Optional 값 반환
boolean isValue = optTest.isPresent();
System.out.println("값 존재 여부: " + isValue); // true

// 값이 없으면 기본값 반환
optTest = Optional.empty();
int value = optTest.orElse(100);
System.out.println("값: " + value); // 값: 100

// Optional 값 여부 처리
optTest = Optional.empty();
optTest.ifPresent(
        value -> System.out.println("값: " + value)
    ); // 출력 x

optTest = Optional.of(100);
optTest.ifPresent(
        value -> System.out.println("값: " + value)
    ); // 값: 100

optTest.ifPresentOrElse(
        value -> System.out.println("값: " + value),
        () -> System.out.println("값이 없음")
    ); // 값: 100

// orElseGet()
int result = optTest.orElseGet(() -> {
        int dummy = 200 * 2;
        return dummy;
    });
System.out.println("결과: " + result); // 결과: 400

```

### Optional 활용 예시

```java
import java.util.*;

class User {
    private String name;
    private Integer id; // null 가능

    public User(String name, Integer id) {
        this.name = name;
        this.id = id;
    }

    public String getName() { return name; }
    public Integer getId() { return id; }

    @Override
    public String toString() {
        return "User{" +
                "name='" + name + '\'' +
                ", id=" + id +
                '}';
    }
}

public class OptionalExam {
    private static final Map<Integer, User> users = new HashMap<>();

    static {
        users.put(1001, new User("신짱구", 1001));
        users.put(1002, new User("김철수", 1002));
        users.put(1003, new User("이훈이", 1003));
    }

    // User 객체 반환
    static Optional<User> getUserById(Integer id) {
        if (id == null) {
            return Optional.empty();
        }
        return Optional.ofNullable(users.get(id));
    }

    public static void main(String[] args) {
        Integer idVal = 1001;
        
        // 있는경우
        System.out.println("─── 있는 경우 ? ───");
        getUserById(idVal).ifPresentOrElse(
                user -> System.out.println("찾음: " + user),
                () -> System.out.println("못찾음")
        ); // 찾음: User{name='신짱구', id=1001}
        
        // 없는경우
        System.out.println("─── 없는 경우 ? ───");
        idVal = 9999;
        getUserById(idVal).ifPresentOrElse(
                user -> System.out.println("찾음: " + user),
                () -> System.out.println("못찾음")
        ); // 못찾음
        
        // null인 경우
        System.out.println("─── null인 경우 ? ───");
        idVal = null;
        getUserById(idVal).ifPresentOrElse(
                user -> System.out.println("찾음: " + user),
                () -> System.out.println("못찾음")
        ); // 못찾음
    }
}
```