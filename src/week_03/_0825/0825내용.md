# [ 3주차 - 0825 ] 스터디 내용

```bash
    금일 커리큘럼
        ├ 09:00 ~ 12:00 자바 프로그래밍 기초 (상속, getter & setter)
        └ 13:00 ~ 18:00 자바 프로그래밍 기초 (메서드 오버라이딩 & 오버로딩, 다형성)
```


## 2. 상속 (inheritance)

> 부모 클래스의 필드와 메서드를 자식 클래스가 물려받는 것 (일반화와 확장 개념 합침)

* 부모 자식간 `is-a` ,`kind-of`로 관계를 표현함.
* 코드 `재사용` 및 `확장성`에 용이하다.


### 기본 예시
```java
class Parent {  // extends 없어도 컴파일시 extends Object 최상위 부모로 상속됨.
    int a = 10;
    int b = 0;
    int c = 5;
}
class Child extends Parent {
    // 부모에 상속되어 필드변수 같이 사용됨

    // 필드의 오버라이드
    int b = 1;
    
    public Child() {
        this.a = 20; // 생성자에서 부모 필드 받아 자기 자신 변경 가능
    }
}
public class Exam {
    public static void main(String[] args) {
        Parent p = new Parent();
        Child c = new Child();
        System.out.println(p.a);    // 10   (부모필드)
        System.out.println(c.a);    // 20   (자식 this)
        System.out.println(c.c);    // 5    (자식인데 부모필드 가져옴)

        // 1. 부모는 자식을 가리킬 수 있음.
        Parent p1 = new Child();
        // Child c1 = new Parent(); // 불가능!

        // 2. 필드는 선언한 타입에 따름.
        System.out.println(p1.b);   // 0  (부모필드)
        System.out.println(c.b);    // 1  (자식필드)
        System.out.println(p1.a);   // 20 (자식 this)

        // 묵시적 형변환 
        Parent p2 = new Child();
        Object obj2 = p2;
        System.out.println(((Parent)obj2).b);  // 0 (부모필드)
        System.out.println(((Child)obj2).b);   // 1 (자식필드)

        if(obj2 instanceof Child) {
            System.out.println("obj2는 Child 타입입니다.");
        }

        // 명시적 형변환
        Child c2 = (Child)obj2;

        System.out.println(c2.b);   // 1 (자식필드)
    }
}

```

> [!WARNIG]
> `Child c1 = new Parent();`가 불가능한 이유 <br>
> 자식(Child)은 부모(Parent)의 모든 필드와 메서드를 가지지만, <br>
> 부모는 자식의 추가된 필드/메서드를 모르기 때문에 <br>
> 부모 객체를 자식 타입으로 변환하면 런타임 오류(컴파일 에러)가 발생함.



### 패키지 다른 경우 예시

```java
// 부모 클래스 (다른 패키지)
// package 경로A;
public class Animal {
    protected String name;
    protected int age;

    // 자식 상속에선 super()로 접근
    public Animal(String name, int age) {
        this.name = name;
        this.age = age;
    }

    public void info() {
        System.out.println("동물이름: " + name);
        System.out.println("동물나이: " + age);
    }
    
    public void speak() {
        System.out.println("-".repeat(5));
        System.out.println("동물이 소리를 낸다");
    }
    
}
```
```java
// 자식 클래스와 사용 예시 (현재 패키지)
// package 경로B;
// import 경로A.Animal;

class Dog extends Animal {
    private String breed;

    public Dog(String name, int age, String breed) {
        super(name, age); // super() : 부모 생성자 호출
        this.breed = breed;
    }

    public void showBreed() {
        System.out.println("견종: " + breed);
    }
    
    @Override
    public void speak() {
        super.speak(); // super.메서드명() : 부모 메서드 호출
        System.out.println("크르릉");
    }
}

public class AnimalExam {
    public static void main(String[] args) {
        Dog dog = new Dog("초코", 3, "슈나우저");
        dog.info();        // 부모 메서드 사용
        dog.showBreed();   // 자식 메서드 사용
    }
}
```
```bash
# 실행 결과
동물이름: 초코
동물나이: 15
견종: 슈나우저
```

**`super` & `super()` 설명**
* `super`: 부모 클래스의 멤버에 접근
* `super()`: 부모 클래스의 생성자 호출
    - 명시하지 않으면 자동으로 `super()` 호출
    - 모든 생성자는 첫 줄에 `super()` 또는 `this()`를 호출해야 함


---

## 3. getter, setter 메서드

- `private` 필드를 외부에서 읽거나 변경할 때 사용하는 메서드.  
- 캡슐화(정보 은닉)를 위해 사용.
- 명칭은 `get필드명` , `set필드명` 으로 정의하여 사용하는 것을 권장. (컨벤션)

```java
class Person {
    private String name; // private 필드

    // getter: 값 읽기
    public String getName() {
        return name;
    }

    // setter: 값 변경
    public void setName(String name) {
        this.name = name;
    }
}

public class Exam {
    public static void main(String[] args) {
        
        Person p = new Person();
        p.setName("홍길동");  // 변경
        System.out.println(p.getName()); // 읽기
    }
}
```

---

## 4. 메서드 오버라이딩

**오버라이딩(Overriding)**

* 부모 클래스에서 정의한 메서드 -> 자식 클래스에서 **재정의**함
* `메서드 이름`, `매개변수`, `반환타입` 모두 **동일**해야 함
* 오버라이딩 사용시 `@Override` 어노테이션 사용 권장

```java
class Animal {
    public void sound() {
        System.out.println("동물이 소리를 낸다");
    }
}

class Dog extends Animal {
    // 자식클래스에서 sound 재정의 됨
    @Override
    public void sound() {
        System.out.println("멍멍!");
    }
}

public class Exam {
    public static void main(String[] args) {
        // 사용 예시
        Animal a = new Dog();
        a.sound();
    }
}
```
```bash
# 실행 결과
멍멍!
```

## 5. 메서드 오버로딩

* **오버로딩(Overloading)** <br>
  같은 이름의 메서드를 **매개변수의 타입/개수**만 다르게 여러 개 정의함.

```java
class Calc {
    public int add(int a, int b) {
        return a + b;
    }
    public double add(double a, double b) {
        return a + b;
    }
    public int add(int a, int b, int c) {
        return a + b + c;
    }
}

// 사용 예시
Calc calc = new Calc();
calc.add(1, 2);         // int 버전
calc.add(1.5, 2.5);     // double 버전
calc.add(1, 2, 3);      // 3개 int 버전
```

---

## 6. 다형성

> 특정 속성을 가지고서 여러가지 형태로 나타내는 성질

**부모 타입으로 자식 타입을 참조**

* 하나의 타입으로 여러 종류의 객체를 다루는 것
* 부모 타입의 참조 변수로 자식 객체를 참조
* 메소드 오버라이딩과 함께 사용
    - 오버라이딩된 메서드를 통해 객체마다 다른 동작을 할 수 있음.

```java
class Animal {
    public void sound() {
        System.out.println("동물이 소리를 낸다");
    }
}

class Dog extends Animal {
    @Override
    public void sound() {
        System.out.println("멍멍!");
    }
}

class Cat extends Animal {
    @Override
    public void sound() {
        System.out.println("야옹~");
    }
}

public class Exam {
    public static void main(String[] args) {
        Animal a0 = new Animal();
        Animal a1 = new Dog(); // 부모 타입 변수로 자식 객체 참조
        Animal a2 = new Cat();

        a0.sound(); // 동물이 소리를 낸다
        a1.sound(); // 멍멍!
        a2.sound(); // 야옹~
    }
}
```

---

## etc.

### 자바에서 클라이언트의 요청을 받아서 응답하는 기술은?

**서블릿 (Servlet)**
* 자바 웹 개발의 가장 근간을 이루는 기술. 
* 모든 자바 웹 프레임워크는 내부적으로 서블릿을 기반으로 동작한다.
* 자바로 만들어진 웹 서버의 부품으로, 클라이언트(웹 브라우저)의 **요청(Request)**을 받고, 그에 맞는 작업(비즈니스 로직)을 수행한 뒤, **응답(Response)**을 생성하는 핵심 역할을 함.
* 비유하자면, 주문을 받고 요리를 완성하는 **주방장**과 같다.


### 매개변수 객체 타입

```java
class Parent {/* ... */}
class child extends Parent {/* ... */}

public class Exam {
    public static void test0(Child child) {/* ... */}
    public static void test1(Object obj) {/* ... */}

    public static void main(String[] args) {

        Parent p1 = new Parent();
        Object p2 = new Parent();

        Parent c1 = new child();
        Child c2 = new child();
        Object c3 = new child();

        test0(c2); // 가능
        // test0(c1); // 불가능  (Child 타입 이여야함)

        // 오브젝트는 최상위 상속으로 오브젝트타입은 다 가능
        test1(p1);
        test1(p2);
        test1(c1);
        test1(c2);
        test1(c3);
    }
}
```