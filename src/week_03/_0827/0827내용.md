# [ 3주차 - 0827 ] 스터디 내용

```bash
    금일 커리큘럼
        ├ 09:00 ~ 12:00 자바 프로그래밍 기초 (오브젝트 오버라이딩, final과 열거형)
        └ 13:00 ~ 18:00 자바 프로그래밍 기초 
```


## 1. 오브젝트 Override

* `Object`가 가진 메서드들을 자기 클래스 목적에 맞게 재정의하여 사용
* 대표적으로 `toString()`, `equals()`, `hashCode()` 등 있음

```java
class Pen {
    private String name;        // 제품명
    private String code;        // 제품코드
    private String type;        // 타입

    public Pen(String name, String code, String type) {
        this.name = name;
        this.code = code;
        this.type = type;
    }

    @Override
    public String toString() {
        return "Pen{" +
                "name='" + name + '\'' +
                ", code='" + code + '\'' +
                ", type='" + type + '\'' +
                '}';
    }

    @Override
    public boolean equals(Object obj) {
        // 자기자신 비교 리턴 - true
        if (this == obj) return true;

        // 비교 대상이 null 이거나, 클래스 타입이 다르면 false
        if (obj == null || getClass() != obj.getClass()) return false;

        // 타입이 같다면 명시적 형변환
        // 형변환 하는 이유는 Object 타입으로 매개변수를 받고 있기 때문
        Pen pen = (Pen) obj;

        // 매개변수 객체와 자기자신과 비교
        return name.equals(pen.name) && code.equals(pen.code) && type.equals(pen.type);
    }

    @Override
    public int hashCode() {
        int result = 17;  // 초기값 (보통 17 사용)
        // 각 필드의 해시를 누적
        // 누적 방식: result = 31 * result + fieldHash
        result = 31 * result + (name != null ? name.hashCode() : 0);
        result = 31 * result + (code != null ? code.hashCode() : 0);
        result = 31 * result + (type != null ? type.hashCode() : 0);
        return result;
    }
}

public class PenExam {
    public static void main(String[] args) {
        Pen p1 = new Pen("파이롯트", "A105", "샤프");
        Pen p2 = new Pen("파이롯트", "A105", "샤프");
        Pen p3 = new Pen("모나미", "B101", "볼펜");

        // toString() Override
        System.out.println(p1.toString());  // Pen{name='파이롯트', code='A105', type='샤프'}
        System.out.println(p1);             // toString() 자동 호출

        // equals() Override
        System.out.println(p1 == p2);       // false
        System.out.println(p1.equals(p2));  // true
        System.out.println(p1.equals(p3));  // false

        // hashCode() Override
        System.out.println(p1.hashCode());  // 2019936075
        System.out.println(p2.hashCode());  // 2019936075
        System.out.println(p3.hashCode());  // -1657557753

    }
}
```

---

## 2. final 키워드와 열거형(enum)

### finnal 키워드 정리

* **finnal** 은 불변성(Immutable) 보장함
  -`final 변수` : 값(참조) 변경 불가
  -`final 메소드` : 오버라이딩 불가
  -`final 클래스` : 상속 불가

```java
import java.util.ArrayList;

public class FinalAll {
    // final 변수 - 값 변경 불가
    private final int MAX_SIZE = 100;  // 선언과 동시에 초기화 (값 변경 불가)
    private final String name;         // 생성자에서 한 번만 초기화 가능
    private final List<String> items;  // 참조는 불변, 내부 요소(add/remove)는 변경 가능

    public FinalExample(String name) {
        this.name = name;               // 생성자에서 초기화 (필수)
        this.items = new ArrayList<>(); // 참조는 한 번만 할당 가능
    }

    // final 메소드 - 오버라이딩 불가
    public final void display() {
        System.out.println("Name: " + name);
    }

    public void addItem(String item) {
        items.add(item);              // ✅ 가능: 참조가 가리키는 리스트의 내용은 변경 가능
        // items = new ArrayList<>(); // ❌ 불가능: 참조 자체를 새로운 객체로 변경 불가
    }
}

// final 클래스 - 상속 불가  (자식에서 ❌ expends 안됨!)
public final class Parent { /* ... */ }

// ❌ 컴파일 오류: final 클래스는 상속할 수 없음. (String, Integer 도 파이널임)
// public class Child extends Parent { /* ... */ }
// public class Child extends String { /* ... */ }
// public class Child extends Integer { /* ... */ }
```

### 열거형(enum)

> 열거형은 서로 관련 있는 **상수들의 집합을 하나의 타입으로 정의**할 수 있게 해주는 특별한 클래스

즉, 의미 없는 숫자나 문자열 상수 대신 **의미 있는 이름을 가진 상수들을 타입 안전하게 사용**할 수 있도록 도와준다. <br>

#### enum 장점

* **타입 안전성** : 컴파일 시점에 타입 체크가 이루어져, 잘못된 값 대입을 방지
* **상수 그룹화** : 관련 있는 상수들을 한 곳에서 관리 가능
  - 예 : 방향의 `동서남북`, 상태의 `시작-진행-종료`
* 싱글톤 보장: 각 열거 상수는 JVM 내에서 하나만 존재 (메모리 효율적)
* switch문 지원: 직관적이고 가독성 좋은 분기문 작성 가능


#### 기본 열거형

```java
package week_03._0827._enum;
// 기본 열거형
public enum Day {
//    MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY, SUNDAY
    월요일, 화요일, 수요일, 목요일, 금요일, 토요일, 일요일
}
```

#### 값과 메서드 가진 열거형

```java
package week_03._0827._enum;
// 값과 메서드 가진 열거형
public enum Order {
    대기("P", "대기중"),
    처리("R", "처리중"),
    배송("S", "배송중"),
    완료("D", "배송완료"),
    취소("C", "취소");

    private final String code;
    private final String info;

    // 생성자
    Order(String code, String info) {
        this.code = code;
        this.info = info;
    }

    public String getCode() {
        return code;
    }

    public String getInfo() {
        return info;
    }

    // 정적 메소드
    public static Order fromCode(String code) {
        for (Order status : Order.values()) {
            if (status.code.equals(code)) {
                return status;
            }
        }
        throw new IllegalArgumentException("Invalid code: " + code);
    }
}
```

#### 열거형 사용예시

```java
package week_03._0827;
import week_03._0827._enum.Day;
import week_03._0827._enum.Order;

public class EnumTest {
    public static void main(String[] args) {
        // 기본열거형 사용
        Day today = Day.월요일;
        switch(today) {
            case 월요일:
            case 화요일:
            case 수요일:
            case 목요일:
            case 금요일:
                System.out.println("평일입니다.");
                break;
            case 토요일:
            case 일요일:
                System.out.println("주말입니다.");
                break;
        }
        System.out.println("-".repeat(5));

        // Order 사용
        Order status = Order.대기;
        System.out.println(status.getInfo());  // 대기중

        System.out.println("-".repeat(5));

        // Order 모든 값 순회
        for (Order s : Order.values()) {
            System.out.println(s.name() + ": " + s.getInfo());
        }

        System.out.println("-".repeat(5));

        // Order 코드로 찾기
        Order found = Order.fromCode("S");
        System.out.println(found);  // SHIPPED
    }
}
```
```bash
# 실행 결과
평일입니다.
-----
대기중
-----
대기: 대기중
처리: 처리중
배송: 배송중
완료: 배송완료
취소: 취소
-----
배송
```

---

## etc.

### 메서드 자동완성 TIP

* IDE : 인텔리제이
    - 단축키 `alt` + `insert`

* IDE : Vscode
    - 마우스 `우측클릭` -> `소스액션`
    - 단축키설정 `ctrl + K` 후 `ctrl + S` -> `source action` 검색 -> 키바인딩 `alt` + `insert` 후 사용